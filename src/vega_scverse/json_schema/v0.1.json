{
  "$defs": {
    "AggregateOpsEnum": {
      "description": "    The summary statistic to apply for an aggregation transform. The summary statistic is calculated per datashade\nraster pixel.",
      "enum": [
        "any",
        "max",
        "min",
        "mean",
        "stdev",
        "sum",
        "variance",
        "count"
      ],
      "title": "AggregateOpsEnum",
      "type": "string"
    },
    "AggregateTransform": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "aggregate",
          "default": "aggregate",
          "description": "The type of transform.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ],
            "equals_string": "aggregate",
            "ifabsent": "string(aggregate)"
          },
          "title": "Type",
          "type": "string"
        },
        "field": {
          "description": "The data fields for which to compute aggregate functions. This array should align with the as \narrays.",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "field",
            "domain_of": [
              "BaseAggregateTransform",
              "BaseSpreadTransform"
            ]
          },
          "title": "Field",
          "type": "array"
        },
        "ops": {
          "description": "The summary statistic to apply per field. This deviates from vega where ops has a single string value\nwhile here it is an array with a length equal to 'field' and 'as'.",
          "items": {
            "$ref": "#/$defs/AggregateOpsEnum"
          },
          "linkml_meta": {
            "alias": "ops",
            "domain_of": [
              "BaseAggregateTransform"
            ]
          },
          "title": "Ops",
          "type": "array"
        },
        "as": {
          "description": "To be added",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "as_",
            "domain_of": [
              "BaseLookupTransform",
              "BaseAggregateTransform",
              "BaseSpreadTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "As",
          "type": "array"
        }
      },
      "required": [
        "field",
        "ops",
        "as"
      ],
      "title": "AggregateTransform",
      "type": "object"
    },
    "AnchorEnum": {
      "description": "The possible values for the anchor of a title or subtitle.",
      "enum": [
        "start",
        "middle",
        "end"
      ],
      "title": "AnchorEnum",
      "type": "string"
    },
    "AxisEnum": {
      "description": "Possible values for the type of",
      "enum": [
        "x",
        "y"
      ],
      "title": "AxisEnum",
      "type": "string"
    },
    "AxisItem": {
      "additionalProperties": false,
      "description": "A axis item which for a mark can define the scale and field used for the axis definition in the mark.",
      "properties": {
        "scale": {
          "description": "The scale on which the axis is based.",
          "linkml_meta": {
            "alias": "scale",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "Axis"
            ]
          },
          "title": "Scale",
          "type": "string"
        },
        "field": {
          "$ref": "#/$defs/AxisEnum",
          "description": "The mark's field value transformed by the scale. Either x or y.",
          "linkml_meta": {
            "alias": "field",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "ContinuousColorDomain"
            ]
          }
        }
      },
      "required": [
        "scale",
        "field"
      ],
      "title": "AxisItem",
      "type": "object"
    },
    "AxisRangeEnum": {
      "description": "Possible values which to map the data domain to.",
      "enum": [
        "height",
        "width"
      ],
      "title": "AxisRangeEnum",
      "type": "string"
    },
    "AxisScale": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "description": "`Y_scale` or `X_scale` optionally followed by `_n` where n stands for the index of the subplot.",
          "linkml_meta": {
            "alias": "name",
            "domain_of": [
              "Scale"
            ]
          },
          "title": "Name",
          "type": "string"
        },
        "type": {
          "const": "linear",
          "default": "linear",
          "description": "Only linear is supported for an `AxisScale` for now.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale"
            ],
            "equals_string": "linear",
            "ifabsent": "string(linear)"
          },
          "title": "Type",
          "type": "string"
        },
        "domain": {
          "description": "The set of input data values that the scale maps from. In the case of a linear scale,\nthis should be a two-element list representing the minimum and maximum numeric values\nto be transformed. For example, [512.0, 0.0] maps the data range from 512 (top) to 0 (bottom),\nwhich is typical for Y-axis scales in image coordinate systems where the origin is at the top-left.",
          "items": {
            "type": "number"
          },
          "linkml_meta": {
            "alias": "domain",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale"
            ]
          },
          "maxItems": 2,
          "minItems": 2,
          "title": "Domain",
          "type": "array"
        },
        "range": {
          "$ref": "#/$defs/AxisRangeEnum",
          "description": "Defines the target visual dimension for the axis scale's output range. Must be either 'width' for an X-axis \nscale or 'height' for a Y-axis scale. These keywords refer to the pixel extent of the plotting area, not the \nfull canvas. The plotting area is the region where data marks are rendered, and its dimensions are typically \ndefined by the top-level 'width' and 'height' properties of a Vega specification. For example, setting \n\"range\": \"height\" in a Y-axis scale maps the scale's domain to pixel positions from top to bottom within the \nplot area. This is commonly used to align data values with positional axes in coordinate-based visualizations.",
          "linkml_meta": {
            "alias": "range",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale"
            ]
          }
        }
      },
      "required": [
        "name",
        "domain",
        "range"
      ],
      "title": "AxisScale",
      "type": "object"
    },
    "BaseLineEnum": {
      "description": "    The possible vertical alignments of the text relative to its y-coordinate.\nSee the link for an explanation of the meaning of EM square. We do not currently\nsupport \"line-bottom\" and \"line-top\".",
      "enum": [
        "top",
        "middle",
        "bottom",
        "alphabetic"
      ],
      "title": "BaseLineEnum",
      "type": "string"
    },
    "BaseLineObject": {
      "additionalProperties": false,
      "description": "The vertical alignment of the text relative to its y-coordinate.",
      "properties": {
        "value": {
          "$ref": "#/$defs/BaseLineEnum",
          "description": "The actual value for vertical alignment.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          }
        }
      },
      "required": [
        "value"
      ],
      "title": "BaseLineObject",
      "type": "object"
    },
    "CapEnum": {
      "description": "The style of the stroke end for axis tick marks.",
      "enum": [
        "butt",
        "round",
        "square"
      ],
      "title": "CapEnum",
      "type": "string"
    },
    "CategoricalColorScale": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "description": "color followed by '_pseudoUUID' used to refer to this scale elsewhere in the view configuration.",
          "linkml_meta": {
            "alias": "name",
            "domain_of": [
              "Scale"
            ]
          },
          "title": "Name",
          "type": "string"
        },
        "type": {
          "const": "ordinal",
          "default": "ordinal",
          "description": "The type of scale which is a description of what kind of mapping is performed between data domain and \nvisual range, e.g. `linear`.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale"
            ],
            "equals_string": "ordinal",
            "ifabsent": "string(ordinal)"
          },
          "title": "Type",
          "type": "string"
        },
        "domain": {
          "description": "The data domain as a list of discrete string values. Length must be equal to the length of range",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "domain",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale"
            ]
          },
          "title": "Domain",
          "type": "array"
        },
        "range": {
          "description": "List of RGB colors as hexadecimal strings. Length must be equal to length of domain",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "range",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale"
            ]
          },
          "title": "Range",
          "type": "array"
        }
      },
      "required": [
        "name",
        "domain",
        "range"
      ],
      "title": "CategoricalColorScale",
      "type": "object"
    },
    "CircleShapeObject": {
      "additionalProperties": false,
      "description": "Circle shape definition used in symbol mark.",
      "properties": {
        "value": {
          "anyOf": [
            {
              "const": "circle",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "circle",
          "description": "Type of shape, in this case circle.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ],
            "equals_string": "circle",
            "ifabsent": "string(circle)"
          },
          "title": "Value"
        }
      },
      "title": "CircleShapeObject",
      "type": "object"
    },
    "ColorItem": {
      "additionalProperties": false,
      "description": "A single color item definition specifying the scale on which the color is based and the value / field\nto which to apply the color.",
      "properties": {
        "scale": {
          "description": "The color scale.",
          "linkml_meta": {
            "alias": "scale",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "Axis"
            ]
          },
          "title": "Scale",
          "type": "string"
        },
        "field": {
          "description": "The value or field to which to apply the color.",
          "linkml_meta": {
            "alias": "field",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "ContinuousColorDomain"
            ]
          },
          "title": "Field",
          "type": "string"
        }
      },
      "required": [
        "scale",
        "field"
      ],
      "title": "ColorItem",
      "type": "object"
    },
    "ConditionalColorUpdate": {
      "additionalProperties": false,
      "description": "Update the color if a value is above or below a given threshold.",
      "properties": {
        "test": {
          "description": "The condition to test on, e.g. 'datum.instance_id) < 3.0'. MUST be an expression starting with \ndatum.<column_name> then a space followed by <=,>=,< or> a space again and then any float or integer value.",
          "linkml_meta": {
            "alias": "test",
            "domain_of": [
              "ConditionalFillUpdate",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Test",
          "type": "string"
        },
        "value": {
          "description": "The color as RGB hex string.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Value",
          "type": "string"
        }
      },
      "required": [
        "test",
        "value"
      ],
      "title": "ConditionalColorUpdate",
      "type": "object"
    },
    "ConditionalFillUpdate": {
      "additionalProperties": false,
      "description": "Update color based on test condition. This is following an 'if-then-else' style chain of production rules. If\nno else is specified, then the property value evaluates to 'null' or similar value.",
      "properties": {
        "test": {
          "description": "The condition to test on, e.g. 'isValid(datum.value). MUST be a valid expression in Vega. See also:\nhttps://vega.github.io/vega/docs/expressions/ and it MUST evaluate to either 'true' or 'false'.",
          "linkml_meta": {
            "alias": "test",
            "domain_of": [
              "ConditionalFillUpdate",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Test",
          "type": "string"
        },
        "scale": {
          "description": "The scale to use for applying the fill color. This scale MUST exist in the view configuration Scales array.",
          "linkml_meta": {
            "alias": "scale",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "Axis"
            ]
          },
          "title": "Scale",
          "type": "string"
        },
        "field": {
          "description": "The column that serves as data input, in the test condition this corresponds to 'datum'.",
          "linkml_meta": {
            "alias": "field",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "ContinuousColorDomain"
            ]
          },
          "title": "Field",
          "type": "string"
        }
      },
      "required": [
        "test",
        "scale",
        "field"
      ],
      "title": "ConditionalFillUpdate",
      "type": "object"
    },
    "ContinuousColorDomain": {
      "additionalProperties": false,
      "description": "A data domain or source for a LinearColorScale.",
      "properties": {
        "data": {
          "description": "The identifier of the particular data object in the data array to which the color mapping in \nLinearColorScale must be applied. In Vega this is only defined when the type of Scale is\nordinal, but we deviate from that.",
          "linkml_meta": {
            "alias": "data",
            "domain_of": [
              "ContinuousColorDomain"
            ]
          },
          "title": "Data",
          "type": "string"
        },
        "field": {
          "description": "If the data source is a table, then the field is the column within the table that is used as \na source for the color mapping. In case of raster data with a single channel, the field equals\n'value' and if multichannel raster data it is the name or index of the image channel.",
          "linkml_meta": {
            "alias": "field",
            "domain_of": [
              "ContinuousColorDomain"
            ]
          },
          "title": "Field",
          "type": "string"
        }
      },
      "required": [
        "data",
        "field"
      ],
      "title": "ContinuousColorDomain",
      "type": "object"
    },
    "ContinuousColorMapRange": {
      "additionalProperties": false,
      "description": "Color scheme reference for a color palette.",
      "properties": {
        "scheme": {
          "description": "The name of the color scheme to use or an array of color values.",
          "linkml_meta": {
            "alias": "scheme",
            "domain_of": [
              "ContinuousColorMapRange"
            ]
          },
          "title": "Scheme",
          "type": "string"
        },
        "count": {
          "description": "The number of colors to use in the scheme.",
          "linkml_meta": {
            "alias": "count",
            "domain_of": [
              "ContinuousColorMapRange"
            ]
          },
          "title": "Count",
          "type": "integer"
        }
      },
      "required": [
        "scheme",
        "count"
      ],
      "title": "ContinuousColorMapRange",
      "type": "object"
    },
    "ElementFormat": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "description": "The type of the data as string, e.g. RasterFormat",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ]
          },
          "title": "Type",
          "type": "string"
        },
        "version": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "linkml_meta": {
            "alias": "version",
            "domain_of": [
              "BaseFormat",
              "SpatialDataFormat",
              "ElementFormat"
            ]
          },
          "title": "Version"
        }
      },
      "required": [
        "type"
      ],
      "title": "ElementFormat",
      "type": "object"
    },
    "FilterChannelTransform": {
      "additionalProperties": false,
      "description": "Filter on particular channels in a raster data object.",
      "properties": {
        "type": {
          "const": "filter_channel",
          "description": "The type of filter transform. 'filter_element' will filter / select a particular element from a data source,\n'filter_cs' will select the coordinate system in which the element should be visualized and 'filter_scale'\nwill select the scale of a multiscale raster data element.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ],
            "equals_string": "filter_channel"
          },
          "title": "Type",
          "type": "string"
        },
        "expr": {
          "anyOf": [
            {
              "items": {
                "anyOf": [
                  {
                    "type": "integer"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The channel(s) to filter the input data stream on. Either a list of integers that correspond to the channel\nindices or list of strings that refer to the name of the channels. Preferably, it SHOULD be the latter to\nprevent a different context when ordering of the channels changes.",
          "linkml_meta": {
            "alias": "expr",
            "any_of": [
              {
                "range": "string"
              },
              {
                "range": "integer"
              }
            ],
            "domain_of": [
              "FilterTransform",
              "FilterChannelTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "Expr"
        }
      },
      "required": [
        "type"
      ],
      "title": "FilterChannelTransform",
      "type": "object"
    },
    "FilterTransform": {
      "additionalProperties": false,
      "description": "Select objects from a data stream to keep based on a filter expression. If the value of the filter expression\nis a single element, e.g. 'blobs_image', then the expression is equivalent to 'datum.value == blobs_image'.\nThese are the first transforms in the array of transforms usually when visualizing SpatialData elements.",
      "properties": {
        "type": {
          "description": "The type of filter transform. 'filter_element' will filter / select a particular element from a data source,\n'filter_cs' will select the coordinate system in which the element should be visualized and 'filter_scale'\nwill select the scale of a multiscale raster data element.",
          "enum": [
            "filter_element",
            "filter_cs",
            "filter_scale",
            "filter_layer"
          ],
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ],
            "equals_string_in": [
              "filter_element",
              "filter_cs",
              "filter_scale",
              "filter_layer"
            ]
          },
          "title": "Type",
          "type": "string"
        },
        "expr": {
          "description": "Either the name of the element or coordinate system to filter / select.",
          "linkml_meta": {
            "alias": "expr",
            "domain_of": [
              "FilterTransform",
              "FilterChannelTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "Expr",
          "type": "string"
        }
      },
      "required": [
        "type",
        "expr"
      ],
      "title": "FilterTransform",
      "type": "object"
    },
    "FontItem": {
      "additionalProperties": false,
      "description": "The  name of the font to be used.",
      "properties": {
        "value": {
          "description": "The value for font name.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Value",
          "type": "string"
        }
      },
      "required": [
        "value"
      ],
      "title": "FontItem",
      "type": "object"
    },
    "FontSizeItem": {
      "additionalProperties": false,
      "description": "Fontsize of text in pixels.",
      "properties": {
        "value": {
          "description": "Font size value.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "minimum": 0,
          "title": "Value",
          "type": "number"
        }
      },
      "required": [
        "value"
      ],
      "title": "FontSizeItem",
      "type": "object"
    },
    "FontStyleEnum": {
      "description": "    Possible font styles. These are all the possible css font styles. These include styles,\nweights, variants and stretch. In case of font weights (100-900), it represents a unitless numeric scale\nstandardized in CSS to represent font weight.",
      "enum": [
        "normal",
        "italic",
        "bold",
        "100",
        "200",
        "300",
        "500",
        "600",
        "800",
        "900",
        "small-caps",
        "ultra-condensed",
        "extra-condensed",
        "condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded"
      ],
      "title": "FontStyleEnum",
      "type": "string"
    },
    "FontStyleItem": {
      "additionalProperties": false,
      "description": "Fontstyle of the text.",
      "properties": {
        "value": {
          "$ref": "#/$defs/FontStyleEnum",
          "description": "The fontstyle value.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          }
        }
      },
      "required": [
        "value"
      ],
      "title": "FontStyleItem",
      "type": "object"
    },
    "FontWeightEnum": {
      "description": "    Possible font weight values. In case of font weights (100-900), it represents a unitless numeric scale\nstandardized in CSS to represent font weight.",
      "enum": [
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
        "bold",
        "normal"
      ],
      "title": "FontWeightEnum",
      "type": "string"
    },
    "FontWeightItem": {
      "additionalProperties": false,
      "description": "Font weight of the text",
      "properties": {
        "value": {
          "$ref": "#/$defs/FontWeightEnum",
          "description": "The font weight value.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          }
        }
      },
      "required": [
        "value"
      ],
      "title": "FontWeightItem",
      "type": "object"
    },
    "GroupEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position of a group mark, which are used for subplots.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene and are the only properties\nsupported for a group mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/GroupEncodeEnter",
          "description": "Enter properties that are evaluated when data for a group mark is processed for the first time and the \ngroup mark is newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "GroupEncode",
      "type": "object"
    },
    "GroupEncodeEnter": {
      "additionalProperties": false,
      "description": "Encoding for the position, width and height of a group mark.",
      "properties": {
        "x": {
          "$ref": "#/$defs/PositiveFloatObject",
          "description": "Placing of the group mark along the x axis (width of the complete charter). The origin\nis on the left side.",
          "linkml_meta": {
            "alias": "x",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "y": {
          "$ref": "#/$defs/PositiveFloatObject",
          "description": "Placing of the group mark along the y axis (height of the complete charter). The origin\nis on the top side.",
          "linkml_meta": {
            "alias": "y",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "width": {
          "$ref": "#/$defs/PositiveFloatObject",
          "description": "The width of the mark in pixels.",
          "linkml_meta": {
            "alias": "width",
            "domain_of": [
              "GroupEncodeEnter"
            ]
          }
        },
        "height": {
          "$ref": "#/$defs/PositiveFloatObject",
          "description": "The height of the mark in pixels.",
          "linkml_meta": {
            "alias": "height",
            "domain_of": [
              "GroupEncodeEnter"
            ]
          }
        }
      },
      "required": [
        "x",
        "y",
        "width",
        "height"
      ],
      "title": "GroupEncodeEnter",
      "type": "object"
    },
    "GroupMark": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "anyOf": [
            {
              "const": "group",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "group",
          "description": "The type of the mark. In this case, it is always 'group'.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "group",
            "ifabsent": "string(group)"
          },
          "title": "Type"
        },
        "encode": {
          "$ref": "#/$defs/GroupEncode",
          "description": "A set of visual encoding properties that determine the position of the group mark.",
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "scales": {
          "description": "Scales map data values (numbers, dates, categories, etc.) to visual values (pixels, colors, sizes).\n    Scales are a fundamental building block of data visualization, as they determine the nature of visual\n    encodings.",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/AxisScale"
              },
              {
                "$ref": "#/$defs/CategoricalColorScale"
              },
              {
                "$ref": "#/$defs/LinearColorScale"
              }
            ]
          },
          "linkml_meta": {
            "alias": "scales",
            "any_of": [
              {
                "range": "BaseAxisScale"
              },
              {
                "range": "BaseCategoricalColorScale"
              },
              {
                "range": "LinearColorScale"
              }
            ],
            "domain_of": [
              "BaseScales",
              "BaseGroupMark"
            ]
          },
          "title": "Scales",
          "type": "array"
        },
        "axes": {
          "description": "Axes visualize spatial scale mappings using ticks, grid lines and labels.",
          "items": {
            "$ref": "#/$defs/vega_scverse__spec_models__linkml_marks__Axis"
          },
          "linkml_meta": {
            "alias": "axes",
            "domain_of": [
              "BaseGroupMark"
            ]
          },
          "title": "Axes",
          "type": "array"
        },
        "legend": {
          "anyOf": [
            {
              "items": {
                "anyOf": [
                  {
                    "$ref": "#/$defs/vega_scverse__spec_models__linkml_marks__CategoricalLegend"
                  },
                  {
                    "$ref": "#/$defs/vega_scverse__spec_models__linkml_marks__ColorBarLegend"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Legends visualize scale mappings for visual values such as color, shape and size.",
          "linkml_meta": {
            "alias": "legend",
            "any_of": [
              {
                "range": "CategoricalLegend"
              },
              {
                "range": "ColorBarLegend"
              }
            ],
            "domain_of": [
              "BaseGroupMark"
            ]
          },
          "title": "Legend"
        },
        "marks": {
          "description": "Graphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting\n        symbols. Marks are the basic visual building block of a visualization, providing basic shapes whose\n        properties can be set according to backing data. Mark property definitions may be simple constants or data\n        fields, or scales can be used to map data values to visual values.",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/PointsMark"
              },
              {
                "$ref": "#/$defs/RasterImageMark"
              },
              {
                "$ref": "#/$defs/RasterLabelMark"
              },
              {
                "$ref": "#/$defs/ShapesMark"
              },
              {
                "$ref": "#/$defs/vega_scverse__spec_models__linkml_marks__TextMark"
              }
            ]
          },
          "linkml_meta": {
            "alias": "marks",
            "any_of": [
              {
                "range": "BaseRasterImageMark"
              },
              {
                "range": "BaseRasterLabelMark"
              },
              {
                "range": "BasePointsMark"
              },
              {
                "range": "BaseShapesMark"
              },
              {
                "range": "TextMark"
              },
              {
                "range": "BaseGroupMark"
              }
            ],
            "domain_of": [
              "BaseGroupMark",
              "BaseViewConfiguration"
            ]
          },
          "title": "Marks",
          "type": "array"
        }
      },
      "required": [
        "encode",
        "scales",
        "axes",
        "marks"
      ],
      "title": "GroupMark",
      "type": "object"
    },
    "HorizontalAlignEnum": {
      "description": "The horizontal text alignment relative to the anchor point of the text. One of left, center, or right.",
      "enum": [
        "left",
        "center",
        "right"
      ],
      "title": "HorizontalAlignEnum",
      "type": "string"
    },
    "HorizontalAlignObject": {
      "additionalProperties": false,
      "description": "Object indicating the horizontal alignment.",
      "properties": {
        "value": {
          "$ref": "#/$defs/HorizontalAlignEnum",
          "description": "The actual value for alignment.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          }
        }
      },
      "required": [
        "value"
      ],
      "title": "HorizontalAlignObject",
      "type": "object"
    },
    "ImageEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position and appearance of a 'raster_image' mark.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene and are the only properties\nsupported for a 'raster_image' mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/ImageEncodeEnter",
          "description": "Enter properties that are evaluated when image data is processed for the first time and the raster_image mark \nis newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "ImageEncode",
      "type": "object"
    },
    "ImageEncodeEnter": {
      "additionalProperties": false,
      "description": "Enter properties that are evaluated when image data is processed for the first time and the raster_image mark is\nnewly added to a scene.",
      "properties": {
        "opacity": {
          "anyOf": [
            {
              "$ref": "#/$defs/OpacityObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The opacity of the image mark.",
          "linkml_meta": {
            "alias": "opacity",
            "domain_of": [
              "ImageEncodeEnter"
            ]
          }
        },
        "fill": {
          "description": "The colormap by which to show the intensity value of the image or channel.",
          "items": {
            "$ref": "#/$defs/ColorItem"
          },
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "title": "Fill",
          "type": "array"
        }
      },
      "required": [
        "fill"
      ],
      "title": "ImageEncodeEnter",
      "type": "object"
    },
    "LabelEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position and appearance of a 'raster_label' mark.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene. The update properties are evaluated\nfor all existing (non-exiting) mark instances. The exit properties are evaluated when the data backing a mark is\nremoved, and so the mark is leaving the visual scene. However, in this specification we currently only support\nenter and update property sets for a 'raster_label' mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/LabelEncodeEnter",
          "description": "Enter properties that are evaluated when label data is processed for the first time and the raster_label mark \nis newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        },
        "update": {
          "anyOf": [
            {
              "$ref": "#/$defs/MarkEncodeUpdate"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update properties that are evaluated for all existing (non-exiting) mark instances. Typically included when \nno random coloring is being used for the labels.",
          "linkml_meta": {
            "alias": "update",
            "domain_of": [
              "LabelEncode",
              "SymbolEncode",
              "PathEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "LabelEncode",
      "type": "object"
    },
    "LabelEncodeEnter": {
      "additionalProperties": false,
      "description": "Enter properties that are evaluated when label data is processed for the first time and the raster_image mark is\nnewly added to a scene.",
      "properties": {
        "stroke": {
          "description": "The color of the outline of each individual label.",
          "items": {
            "$ref": "#/$defs/ColorItem"
          },
          "linkml_meta": {
            "alias": "stroke",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          },
          "maxItems": 1,
          "minItems": 1,
          "title": "Stroke",
          "type": "array"
        },
        "fill": {
          "description": "The color fill of each individual label.",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/ColorItem"
              },
              {
                "$ref": "#/$defs/RandomRGBSignal"
              }
            ]
          },
          "linkml_meta": {
            "alias": "fill",
            "any_of": [
              {
                "range": "ColorItem"
              },
              {
                "range": "RandomRGBSignal"
              }
            ],
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "maxItems": 1,
          "minItems": 1,
          "title": "Fill",
          "type": "array"
        },
        "fillOpacity": {
          "$ref": "#/$defs/OpacityObject",
          "description": "Opacity value for the label fill between 0 and 1.",
          "linkml_meta": {
            "alias": "fillOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter"
            ]
          }
        },
        "strokeOpacity": {
          "$ref": "#/$defs/OpacityObject",
          "description": "Opacity value for the label stroke between 0 and 1.",
          "linkml_meta": {
            "alias": "strokeOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          }
        },
        "strokeWidth": {
          "$ref": "#/$defs/PositiveFloatObject",
          "description": "The width of the label outlines in pixels.",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "Legend"
            ]
          }
        }
      },
      "required": [
        "stroke",
        "fill",
        "fillOpacity",
        "strokeOpacity",
        "strokeWidth"
      ],
      "title": "LabelEncodeEnter",
      "type": "object"
    },
    "LegendDirections": {
      "description": "The possible directions of the legend.",
      "enum": [
        "horizontal",
        "vertical"
      ],
      "title": "LegendDirections",
      "type": "string"
    },
    "LegendType": {
      "description": "The valid mark types within the scverse plotting / visualization ecosystem.",
      "enum": [
        "discrete",
        "gradient"
      ],
      "title": "LegendType",
      "type": "string"
    },
    "LinearColorScale": {
      "additionalProperties": false,
      "description": "A vega like scale specifically for mapping from a linear continuous data domain to a visual color range.",
      "properties": {
        "name": {
          "description": "color followed by '_pseudoUUID' used to refer to this scale elsewhere in the view configuration.",
          "linkml_meta": {
            "alias": "name",
            "domain_of": [
              "Scale"
            ]
          },
          "title": "Name",
          "type": "string"
        },
        "type": {
          "const": "linear",
          "default": "linear",
          "description": "Only linear is supported for an `LinearColorScale` for now.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale"
            ],
            "equals_string": "linear",
            "ifabsent": "string(linear)"
          },
          "title": "Type",
          "type": "string"
        },
        "domain": {
          "$ref": "#/$defs/ContinuousColorDomain",
          "description": "The data used as a source for the visual color range",
          "linkml_meta": {
            "alias": "domain",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale"
            ]
          }
        },
        "range": {
          "$ref": "#/$defs/ContinuousColorMapRange",
          "description": "The range to which to map the data domain. In this case one that refers to a colormap range.",
          "linkml_meta": {
            "alias": "range",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale"
            ]
          }
        }
      },
      "required": [
        "name",
        "domain",
        "range"
      ],
      "title": "LinearColorScale",
      "type": "object"
    },
    "LookupTransform": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "lookup",
          "default": "lookup",
          "description": "The type of transform.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ],
            "equals_string": "lookup",
            "ifabsent": "string(lookup)"
          },
          "title": "Type",
          "type": "string"
        },
        "from": {
          "description": "The name of the secondary data stream upon which to perform the lookup.",
          "linkml_meta": {
            "alias": "from_",
            "domain_of": [
              "BaseLookupTransform"
            ]
          },
          "title": "From",
          "type": "string"
        },
        "key": {
          "description": "The key field on the secondary stream, e.g. in table lookup it would be for example instance_id.",
          "linkml_meta": {
            "alias": "key",
            "domain_of": [
              "BaseLookupTransform"
            ]
          },
          "title": "Key",
          "type": "string"
        },
        "fields": {
          "description": "The data fields to copy from the secondary stream to the primary stream.",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "fields",
            "domain_of": [
              "BaseLookupTransform"
            ]
          },
          "title": "Fields",
          "type": "array"
        },
        "values": {
          "description": "To be added",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "values",
            "domain_of": [
              "BaseLookupTransform"
            ]
          },
          "title": "Values",
          "type": "array"
        },
        "as": {
          "description": "To be added",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "as_",
            "domain_of": [
              "BaseLookupTransform",
              "BaseAggregateTransform",
              "BaseSpreadTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "As",
          "type": "array"
        },
        "default": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The default value to assign if lookup fails",
          "linkml_meta": {
            "alias": "default",
            "domain_of": [
              "BaseLookupTransform"
            ]
          },
          "title": "Default"
        }
      },
      "required": [
        "from",
        "key",
        "fields",
        "values",
        "as"
      ],
      "title": "LookupTransform",
      "type": "object"
    },
    "MarkDataSource": {
      "additionalProperties": false,
      "description": "Object with a data field pointing to the name of the datastream that serves as data source for the mark.",
      "properties": {
        "data": {
          "description": "name of the datastream",
          "linkml_meta": {
            "alias": "data",
            "domain_of": [
              "ContinuousColorDomain",
              "MarkDataSource"
            ]
          },
          "title": "Data",
          "type": "string"
        }
      },
      "required": [
        "data"
      ],
      "title": "MarkDataSource",
      "type": "object"
    },
    "MarkEncodeUpdate": {
      "additionalProperties": false,
      "description": "Update properties that are evaluated for all existing (non-exiting) mark instances.",
      "properties": {
        "fill": {
          "anyOf": [
            {
              "items": {
                "anyOf": [
                  {
                    "$ref": "#/$defs/ConditionalColorUpdate"
                  },
                  {
                    "$ref": "#/$defs/ConditionalFillUpdate"
                  },
                  {
                    "$ref": "#/$defs/NAColorUpdate"
                  },
                  {
                    "$ref": "#/$defs/RGBHexItem"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update of fill color based on a test condition and optional a backup static fill value",
          "linkml_meta": {
            "alias": "fill",
            "any_of": [
              {
                "range": "ConditionalFillUpdate"
              },
              {
                "range": "RGBHexItem"
              },
              {
                "range": "NAColorUpdate"
              },
              {
                "range": "ConditionalColorUpdate"
              }
            ],
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "title": "Fill"
        }
      },
      "title": "MarkEncodeUpdate",
      "type": "object"
    },
    "NAColorUpdate": {
      "additionalProperties": false,
      "description": "Update the color of a mark glyph if its value is not valid.",
      "properties": {
        "test": {
          "description": "The condition to test on, e.g. '!isValid(datum.value). MUST be a negating is valid expression in Vega. \nSee also: https://vega.github.io/vega/docs/expressions/ and it MUST evaluate to either 'true' or 'false'.",
          "linkml_meta": {
            "alias": "test",
            "domain_of": [
              "ConditionalFillUpdate",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Test",
          "type": "string"
        },
        "value": {
          "description": "The color as RGB hex string.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Value",
          "type": "string"
        }
      },
      "required": [
        "test",
        "value"
      ],
      "title": "NAColorUpdate",
      "type": "object"
    },
    "NormalizationFormulaTransform": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "formula",
          "default": "formula",
          "description": "The type of transform.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ],
            "equals_string": "formula",
            "ifabsent": "string(formula)"
          },
          "title": "Type",
          "type": "string"
        },
        "expr": {
          "description": "Formula represented as string that in this case applies a normalization on the data. The column or field of \ndata that is normalized is indicated as 'datum.<name_of_column>'.",
          "linkml_meta": {
            "alias": "expr",
            "domain_of": [
              "FilterTransform",
              "FilterChannelTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "Expr",
          "type": "string"
        },
        "as": {
          "description": "To be added",
          "linkml_meta": {
            "alias": "as_",
            "domain_of": [
              "BaseLookupTransform",
              "BaseAggregateTransform",
              "BaseSpreadTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "As",
          "type": "string"
        }
      },
      "required": [
        "expr",
        "as"
      ],
      "title": "NormalizationFormulaTransform",
      "type": "object"
    },
    "OpacityObject": {
      "additionalProperties": false,
      "description": "The opacity for a given mark or label or other item to be rendered.",
      "properties": {
        "value": {
          "description": "The actual opacity value",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Value",
          "type": "number"
        }
      },
      "required": [
        "value"
      ],
      "title": "OpacityObject",
      "type": "object"
    },
    "OrientEnum": {
      "description": "The position relative to the chart for either a (sub)title or axis.",
      "enum": [
        "left",
        "right",
        "top",
        "bottom"
      ],
      "title": "OrientEnum",
      "type": "string"
    },
    "Padding": {
      "additionalProperties": false,
      "description": "padding defines the amount of space (in pixels) to reserve between the edge of the chart container and the inner\nview area where data marks are rendered. It acts as an internal margin that ensures visual elements like axes,\ntitles, and legends don't touch or overflow the chart's outer boundaries.\nWhen combined with \"autosize\": {\"type\": \"fit\", \"contains\": \"padding\"}, this padding is included within the chart's\nspecified width and height, and the inner view is resized accordingly to preserve layout integrity. If padding\nis defined with this class. This class should at least have one attribute defined.",
      "properties": {
        "left": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The value for padding at the left side of the chart in pixels.",
          "linkml_meta": {
            "alias": "left",
            "domain_of": [
              "Padding"
            ]
          },
          "title": "Left"
        },
        "top": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The value for padding at the top side of the chart in pixels.",
          "linkml_meta": {
            "alias": "top",
            "domain_of": [
              "Padding"
            ]
          },
          "title": "Top"
        },
        "right": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The value for padding at the right side of the chart in pixels.",
          "linkml_meta": {
            "alias": "right",
            "domain_of": [
              "Padding"
            ]
          },
          "title": "Right"
        },
        "bottom": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The value for padding at the bottom side of the chart in pixels.",
          "linkml_meta": {
            "alias": "bottom",
            "domain_of": [
              "Padding"
            ]
          },
          "title": "Bottom"
        }
      },
      "title": "Padding",
      "type": "object"
    },
    "PathEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position and appearance of a 'path' mark.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene. The update properties are evaluated\nfor all existing (non-exiting) mark instances. The exit properties are evaluated when the data backing a mark is\nremoved, and so the mark is leaving the visual scene. However, in this specification we currently only support\nenter and update property sets for a 'path' mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/PathEncodeEnter",
          "description": "Enter properties that are evaluated when points data is processed for the first time and the points mark \nis newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        },
        "update": {
          "anyOf": [
            {
              "$ref": "#/$defs/MarkEncodeUpdate"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update properties that are evaluated for all existing (non-exiting) mark instances. Usually defined if the \nuser specified a color to be used for the PointsMark.",
          "linkml_meta": {
            "alias": "update",
            "domain_of": [
              "LabelEncode",
              "SymbolEncode",
              "PathEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "PathEncode",
      "type": "object"
    },
    "PathEncodeEnter": {
      "additionalProperties": false,
      "description": "Enter properties that are evaluated when shapes data is processed for the first time and the raster_image mark is\nnewly added to a scene.",
      "properties": {
        "x": {
          "$ref": "#/$defs/AxisItem",
          "description": "The x coordinates",
          "linkml_meta": {
            "alias": "x",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "y": {
          "$ref": "#/$defs/AxisItem",
          "description": "The y coordinates",
          "linkml_meta": {
            "alias": "y",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "fill": {
          "anyOf": [
            {
              "$ref": "#/$defs/ColorItem"
            },
            {
              "$ref": "#/$defs/RGBHexItem"
            }
          ],
          "description": "The color fill of each individual label.",
          "linkml_meta": {
            "alias": "fill",
            "any_of": [
              {
                "range": "ColorItem"
              },
              {
                "range": "RGBHexItem"
              }
            ],
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "title": "Fill"
        },
        "fillOpacity": {
          "$ref": "#/$defs/OpacityObject",
          "description": "The fill opacity of the individual shape geometries.",
          "linkml_meta": {
            "alias": "fillOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter"
            ]
          }
        },
        "stroke": {
          "anyOf": [
            {
              "$ref": "#/$defs/RGBHexItem"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The color of the shapes outlines as RGB hexstring",
          "linkml_meta": {
            "alias": "stroke",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          }
        },
        "strokeWidth": {
          "anyOf": [
            {
              "$ref": "#/$defs/PositiveFloatObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The width of the outline in pixels",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "Legend"
            ]
          }
        },
        "strokeOpacity": {
          "anyOf": [
            {
              "$ref": "#/$defs/OpacityObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The opacity of the outline of the individual shape geometries.",
          "linkml_meta": {
            "alias": "strokeOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          }
        }
      },
      "required": [
        "x",
        "y",
        "fill",
        "fillOpacity"
      ],
      "title": "PathEncodeEnter",
      "type": "object"
    },
    "PointsEncodeEnter": {
      "additionalProperties": false,
      "description": "Enter properties that are evaluated when points data is processed for the first time and the raster_image mark is\nnewly added to a scene.",
      "properties": {
        "x": {
          "$ref": "#/$defs/AxisItem",
          "description": "The x coordinates",
          "linkml_meta": {
            "alias": "x",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "y": {
          "$ref": "#/$defs/AxisItem",
          "description": "The y coordinates",
          "linkml_meta": {
            "alias": "y",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "stroke": {
          "anyOf": [
            {
              "$ref": "#/$defs/ColorItem"
            },
            {
              "$ref": "#/$defs/RGBHexItem"
            }
          ],
          "description": "The color of the outline of each individual point.",
          "linkml_meta": {
            "alias": "stroke",
            "any_of": [
              {
                "range": "ColorItem"
              },
              {
                "range": "RGBHexItem"
              }
            ],
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          },
          "title": "Stroke"
        },
        "fill": {
          "anyOf": [
            {
              "$ref": "#/$defs/ColorItem"
            },
            {
              "$ref": "#/$defs/RGBHexItem"
            }
          ],
          "description": "The color fill of each individual point.",
          "linkml_meta": {
            "alias": "fill",
            "any_of": [
              {
                "range": "ColorItem"
              },
              {
                "range": "RGBHexItem"
              }
            ],
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "title": "Fill"
        },
        "fillOpacity": {
          "$ref": "#/$defs/OpacityObject",
          "description": "Opacity value for the point fill between 0 and 1.",
          "linkml_meta": {
            "alias": "fillOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter"
            ]
          }
        },
        "strokeOpacity": {
          "anyOf": [
            {
              "$ref": "#/$defs/OpacityObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity value for the point outlines between 0 and 1.",
          "linkml_meta": {
            "alias": "strokeOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          }
        },
        "strokeWidth": {
          "anyOf": [
            {
              "$ref": "#/$defs/PositiveFloatObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The width of the point outlines in pixels.",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "Legend"
            ]
          }
        },
        "size": {
          "$ref": "#/$defs/PositiveFloatObject",
          "description": "The points bounding box area size (typographic points are 1/72 in.).",
          "linkml_meta": {
            "alias": "size",
            "domain_of": [
              "PointsEncodeEnter"
            ]
          }
        },
        "shape": {
          "$ref": "#/$defs/CircleShapeObject",
          "description": "The type of shape. In this case `circle`.",
          "linkml_meta": {
            "alias": "shape",
            "domain_of": [
              "PointsEncodeEnter"
            ]
          }
        }
      },
      "required": [
        "x",
        "y",
        "stroke",
        "fill",
        "fillOpacity",
        "size",
        "shape"
      ],
      "title": "PointsEncodeEnter",
      "type": "object"
    },
    "PointsMark": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "symbol",
          "default": "symbol",
          "description": "The type of the mark. In this case, it is always 'symbol'.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "symbol",
            "ifabsent": "string(symbol)"
          },
          "title": "Type",
          "type": "string"
        },
        "from": {
          "$ref": "#/$defs/MarkDataSource",
          "description": "The data stream used as the source for the graphical mark.",
          "linkml_meta": {
            "alias": "from_",
            "domain_of": [
              "Mark"
            ]
          }
        },
        "encode": {
          "$ref": "#/$defs/SymbolEncode",
          "description": "A set of visual encoding properties that determine the position and appearance of the symbol mark.",
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "zindex": {
          "description": "An integer z-index indicating the layering order of sibling mark items. The default value is 0. Higher values \n(1) will cause marks to be drawn on top of those with lower z-index values.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "integer"
        }
      },
      "required": [
        "from",
        "encode",
        "zindex"
      ],
      "title": "PointsMark",
      "type": "object"
    },
    "PositionItem": {
      "additionalProperties": false,
      "description": "X or y position of an item in pixels.",
      "properties": {
        "value": {
          "description": "The coordinate value.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Value",
          "type": "number"
        }
      },
      "required": [
        "value"
      ],
      "title": "PositionItem",
      "type": "object"
    },
    "PositiveFloatObject": {
      "additionalProperties": false,
      "description": "An object with an attribute value with a positive float as range. Useful for example to note the width of an\noutline.",
      "properties": {
        "value": {
          "description": "The actual width value in  pixels",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "minimum": 0,
          "title": "Value",
          "type": "number"
        }
      },
      "required": [
        "value"
      ],
      "title": "PositiveFloatObject",
      "type": "object"
    },
    "RGBHexItem": {
      "additionalProperties": false,
      "description": "RGB value represented by a hexadecimal string value.",
      "properties": {
        "value": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The RGB hex string value.",
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Value"
        }
      },
      "title": "RGBHexItem",
      "type": "object"
    },
    "RandomRGBSignal": {
      "additionalProperties": false,
      "description": "RGB value represented by a hexadecimal string value.",
      "properties": {
        "signal": {
          "anyOf": [
            {
              "const": "rgb(random()*255, random()*255, random()*255)",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "rgb",
          "description": "Signal creating random RGB color for labels in a label raster.",
          "linkml_meta": {
            "alias": "signal",
            "domain_of": [
              "RandomRGBSignal"
            ],
            "equals_string": "rgb(random()*255, random()*255, random()*255)",
            "ifabsent": "string(rgb(random()*255, random()*255, random()*255))"
          },
          "title": "Signal"
        }
      },
      "title": "RandomRGBSignal",
      "type": "object"
    },
    "RasterImageMark": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "raster_image",
          "default": "raster_image",
          "description": "The type of the mark. In this case, it is always 'raster_image'",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "raster_image",
            "ifabsent": "string(raster_image)"
          },
          "title": "Type",
          "type": "string"
        },
        "from": {
          "$ref": "#/$defs/MarkDataSource",
          "description": "The data stream used as the source for the graphical mark.",
          "linkml_meta": {
            "alias": "from_",
            "domain_of": [
              "Mark"
            ]
          }
        },
        "encode": {
          "$ref": "#/$defs/ImageEncode",
          "description": "A set of visual encoding properties that determine the position and appearance of the raster_image mark.",
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "zindex": {
          "description": "An integer z-index indicating the layering order of sibling mark items. The default value is 0. Higher values \n(1) will cause marks to be drawn on top of those with lower z-index values.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "integer"
        }
      },
      "required": [
        "from",
        "encode",
        "zindex"
      ],
      "title": "RasterImageMark",
      "type": "object"
    },
    "RasterLabelMark": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "raster_label",
          "default": "raster_label",
          "description": "The type of the mark. In this case, it is always 'raster_label'",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "raster_label",
            "ifabsent": "string(raster_label)"
          },
          "title": "Type",
          "type": "string"
        },
        "from": {
          "$ref": "#/$defs/MarkDataSource",
          "description": "The data stream used as the source for the graphical mark.",
          "linkml_meta": {
            "alias": "from_",
            "domain_of": [
              "Mark"
            ]
          }
        },
        "encode": {
          "$ref": "#/$defs/LabelEncode",
          "description": "A set of visual encoding properties that determine the position and appearance of the raster_image mark.",
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "zindex": {
          "description": "An integer z-index indicating the layering order of sibling mark items. The default value is 0. Higher values \n(1) will cause marks to be drawn on top of those with lower z-index values.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "integer"
        }
      },
      "required": [
        "from",
        "encode",
        "zindex"
      ],
      "title": "RasterLabelMark",
      "type": "object"
    },
    "ShapesMark": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "path",
          "default": "path",
          "description": "The type of the mark. In this case, it is always 'symbol'.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "path",
            "ifabsent": "string(path)"
          },
          "title": "Type",
          "type": "string"
        },
        "from": {
          "$ref": "#/$defs/MarkDataSource",
          "description": "The data stream used as the source for the graphical mark.",
          "linkml_meta": {
            "alias": "from_",
            "domain_of": [
              "Mark"
            ]
          }
        },
        "encode": {
          "$ref": "#/$defs/PathEncode",
          "description": "A set of visual encoding properties that determine the position and appearance of the symbol mark.",
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "zindex": {
          "description": "An integer z-index indicating the layering order of sibling mark items. The default value is 0. Higher values \n(1) will cause marks to be drawn on top of those with lower z-index values.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "integer"
        }
      },
      "required": [
        "from",
        "encode",
        "zindex"
      ],
      "title": "ShapesMark",
      "type": "object"
    },
    "SpatialDataElementObject": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "description": "The name used throughout the view configuration to refer to the data object. It is an arbitrary string \nfollowed by an underscore and pseudo UUID.",
          "linkml_meta": {
            "alias": "name",
            "domain_of": [
              "DataObject"
            ]
          },
          "title": "Name",
          "type": "string"
        },
        "format": {
          "$ref": "#/$defs/ElementFormat",
          "linkml_meta": {
            "alias": "format",
            "domain_of": [
              "DataObject",
              "SpatialDataObject",
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          }
        },
        "source": {
          "description": "The source of the SpatialData element. Must be the name / identifier of a SpatialData Object in the \nview configuration.",
          "linkml_meta": {
            "alias": "source",
            "domain_of": [
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          },
          "title": "Source",
          "type": "string"
        },
        "transform": {
          "description": "An array of transforms applied to the SpatialData element. The first transform is always `filter_element`,\n    which filters the SpatialData source object based on the element name. This is followed by `filter_cs`, to\n    specify in which coordinate system the element should be visualized. This can be followed by other optional\n    transforms.",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/AggregateTransform"
              },
              {
                "$ref": "#/$defs/LookupTransform"
              },
              {
                "$ref": "#/$defs/NormalizationFormulaTransform"
              },
              {
                "$ref": "#/$defs/SpreadTransform"
              },
              {
                "$ref": "#/$defs/FilterChannelTransform"
              },
              {
                "$ref": "#/$defs/FilterTransform"
              }
            ]
          },
          "linkml_meta": {
            "alias": "transform",
            "any_of": [
              {
                "range": "BaseLookupTransform"
              },
              {
                "range": "FilterTransform"
              },
              {
                "range": "FilterChannelTransform"
              },
              {
                "range": "BaseAggregateTransform"
              },
              {
                "range": "BaseSpreadTransform"
              },
              {
                "range": "BaseNormalizationFormulaTransform"
              }
            ],
            "domain_of": [
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          },
          "title": "Transform",
          "type": "array"
        }
      },
      "required": [
        "name",
        "format",
        "source",
        "transform"
      ],
      "title": "SpatialDataElementObject",
      "type": "object"
    },
    "SpatialDataFormat": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "description": "The type of the data as string, e.g. RasterFormat",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat",
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          },
          "title": "Type",
          "type": "string"
        },
        "version": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "linkml_meta": {
            "alias": "version",
            "domain_of": [
              "BaseFormat",
              "SpatialDataFormat",
              "ElementFormat"
            ]
          },
          "title": "Version"
        }
      },
      "required": [
        "type"
      ],
      "title": "SpatialDataFormat",
      "type": "object"
    },
    "SpatialDataObject": {
      "additionalProperties": false,
      "description": "SpatialData object specific to the SpatialData root",
      "properties": {
        "name": {
          "description": "The name used throughout the view configuration to refer to the data object. It is an arbitrary string \nfollowed by an underscore and pseudo UUID.",
          "linkml_meta": {
            "alias": "name",
            "domain_of": [
              "DataObject",
              "Scale"
            ]
          },
          "title": "Name",
          "type": "string"
        },
        "format": {
          "anyOf": [
            {
              "$ref": "#/$defs/SpatialDataFormat"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "linkml_meta": {
            "alias": "format",
            "domain_of": [
              "DataObject",
              "SpatialDataObject",
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          }
        },
        "url": {
          "description": "The absolute path to the SpatialData zarr.",
          "linkml_meta": {
            "alias": "url",
            "domain_of": [
              "SpatialDataObject"
            ]
          },
          "title": "Url",
          "type": "string"
        }
      },
      "required": [
        "name",
        "url"
      ],
      "title": "SpatialDataObject",
      "type": "object"
    },
    "SpreadTransform": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "spread",
          "default": "spread",
          "description": "The type of transform.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat"
            ],
            "equals_string": "spread",
            "ifabsent": "string(spread)"
          },
          "title": "Type",
          "type": "string"
        },
        "field": {
          "description": "The data fields on which to apply the spread transform. This array should align with the as \narrays.",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "field",
            "domain_of": [
              "BaseAggregateTransform",
              "BaseSpreadTransform"
            ]
          },
          "title": "Field",
          "type": "array"
        },
        "px": {
          "description": "The amount of pixels by which to expand each pixel to make data more visible.",
          "linkml_meta": {
            "alias": "px",
            "domain_of": [
              "BaseSpreadTransform"
            ]
          },
          "title": "Px",
          "type": "integer"
        },
        "as": {
          "description": "To be added",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "as_",
            "domain_of": [
              "BaseLookupTransform",
              "BaseAggregateTransform",
              "BaseSpreadTransform",
              "BaseNormalizationFormulaTransform"
            ]
          },
          "title": "As",
          "type": "array"
        }
      },
      "required": [
        "field",
        "px",
        "as"
      ],
      "title": "SpreadTransform",
      "type": "object"
    },
    "SymbolEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position and appearance of a 'symbol' mark.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene. The update properties are evaluated\nfor all existing (non-exiting) mark instances. The exit properties are evaluated when the data backing a mark is\nremoved, and so the mark is leaving the visual scene. However, in this specification we currently only support\nenter and update property sets for a 'symbol' mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/PointsEncodeEnter",
          "description": "Enter properties that are evaluated when points data is processed for the first time and the points mark \nis newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        },
        "update": {
          "anyOf": [
            {
              "$ref": "#/$defs/MarkEncodeUpdate"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update properties that are evaluated for all existing (non-exiting) mark instances. Usually defined if the \nuser specified a color to be used for the PointsMark.",
          "linkml_meta": {
            "alias": "update",
            "domain_of": [
              "LabelEncode",
              "SymbolEncode",
              "PathEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "SymbolEncode",
      "type": "object"
    },
    "TableObject": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "description": "The name used throughout the view configuration to refer to the data object. It is an arbitrary string \nfollowed by an underscore and pseudo UUID.",
          "linkml_meta": {
            "alias": "name",
            "domain_of": [
              "DataObject"
            ]
          },
          "title": "Name",
          "type": "string"
        },
        "format": {
          "$ref": "#/$defs/ElementFormat",
          "linkml_meta": {
            "alias": "format",
            "domain_of": [
              "DataObject",
              "SpatialDataObject",
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          }
        },
        "source": {
          "description": "The source of the SpatialData element. Must be the name / identifier of a SpatialData Object in the \nview configuration.",
          "linkml_meta": {
            "alias": "source",
            "domain_of": [
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          },
          "title": "Source",
          "type": "string"
        },
        "transform": {
          "description": "An array containing a single transform 'filter_element' with an expression stating which table to obtain\nfrom the source SpatialData object stream.",
          "items": {
            "$ref": "#/$defs/FilterTransform"
          },
          "linkml_meta": {
            "alias": "transform",
            "domain_of": [
              "BaseTableObject",
              "BaseSpatialDataElementObject"
            ]
          },
          "title": "Transform",
          "type": "array"
        }
      },
      "required": [
        "name",
        "format",
        "source",
        "transform"
      ],
      "title": "TableObject",
      "type": "object"
    },
    "TextItem": {
      "additionalProperties": false,
      "description": "Text to be displayed. Value is an array where each element corresponds to 1 line.",
      "properties": {
        "value": {
          "description": "The value for text.",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "value",
            "domain_of": [
              "PositionItem",
              "TextItem",
              "baselineItem",
              "FontItem",
              "FontSizeItem",
              "FontWeightItem",
              "FontStyleItem",
              "RGBHexItem",
              "PositiveFloatObject",
              "CircleShapeObject",
              "OpacityObject",
              "HorizontalAlignObject",
              "BaseLineObject",
              "NAColorUpdate",
              "ConditionalColorUpdate"
            ]
          },
          "title": "Value",
          "type": "array"
        }
      },
      "required": [
        "value"
      ],
      "title": "TextItem",
      "type": "object"
    },
    "Title": {
      "additionalProperties": false,
      "description": "The title directive adds a descriptive title to a chart. Similar to scales, axes, and legends, a title can be\ndefined at the top-level of a specification or as part of a group mark.",
      "properties": {
        "text": {
          "description": "The title text. Either a string or an array of strings. The latter specifies multiple lines of text.",
          "items": {
            "type": "string"
          },
          "linkml_meta": {
            "alias": "text",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          },
          "title": "Text",
          "type": "array"
        },
        "anchor": {
          "$ref": "#/$defs/AnchorEnum",
          "description": "The anchor position for placing the title and subtitle. One of start, middle (the default), or end.",
          "linkml_meta": {
            "alias": "anchor",
            "domain_of": [
              "Title"
            ]
          }
        },
        "orient": {
          "$ref": "#/$defs/OrientEnum",
          "description": "The orientation of the title relative to the chart.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Axis",
              "Legend",
              "Title"
            ]
          }
        },
        "baseline": {
          "$ref": "#/$defs/BaseLineEnum",
          "description": "The baseline attribute specifies the vertical alignment (baseline) of the text relative to its y-coordinate.",
          "linkml_meta": {
            "alias": "baseline",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "color": {
          "description": "Text color of the title text.",
          "linkml_meta": {
            "alias": "color",
            "domain_of": [
              "Title"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Color",
          "type": "string"
        },
        "font": {
          "description": "Font name of the title text.",
          "linkml_meta": {
            "alias": "font",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          },
          "title": "Font",
          "type": "string"
        },
        "fontSize": {
          "description": "Font size in pixels of the title text.",
          "linkml_meta": {
            "alias": "fontSize",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          },
          "minimum": 0,
          "title": "Fontsize",
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/$defs/FontStyleEnum",
          "description": "Fontstyle of the title.",
          "linkml_meta": {
            "alias": "fontStyle",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontWeight": {
          "$ref": "#/$defs/FontWeightEnum",
          "description": "Font weight of the title",
          "linkml_meta": {
            "alias": "fontWeight",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        }
      },
      "required": [
        "text",
        "anchor",
        "orient",
        "baseline",
        "color",
        "font",
        "fontSize",
        "fontStyle",
        "fontWeight"
      ],
      "title": "Title",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_marks__Axis": {
      "additionalProperties": false,
      "description": "An axis visualizes a spatial scale mapping for cartesian coordinates using ticks, grid lines and labels.",
      "properties": {
        "scale": {
          "description": "Name of the 'AxisScale' to visualize as axis object.",
          "linkml_meta": {
            "alias": "scale",
            "domain_of": [
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate",
              "Axis"
            ]
          },
          "title": "Scale",
          "type": "string"
        },
        "orient": {
          "$ref": "#/$defs/OrientEnum",
          "description": "The orientation of the axis, either 'left', 'right', 'top' or 'bottom'.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Title",
              "Axis",
              "Legend"
            ]
          }
        },
        "domain": {
          "description": "A boolean flag indicating if the domain (the axis baseline, the line that the ticks connect to) should be \nincluded as part of the axis.",
          "linkml_meta": {
            "alias": "domain",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale",
              "Axis"
            ]
          },
          "title": "Domain",
          "type": "boolean"
        },
        "domainOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis domain line. Should not be present if domain is 'false'.",
          "linkml_meta": {
            "alias": "domainOpacity",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Domainopacity"
        },
        "domainColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Color of axis domain line. Should not be present if domain is 'false'.",
          "linkml_meta": {
            "alias": "domainColor",
            "domain_of": [
              "Axis"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Domaincolor"
        },
        "domainWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Stroke width of axis domain line. Should not be present if domain is 'false'.",
          "linkml_meta": {
            "alias": "domainWidth",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Domainwidth"
        },
        "grid": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": false,
          "description": "A boolean flag indicating if grid lines should be included as part of the axis.",
          "linkml_meta": {
            "alias": "grid",
            "domain_of": [
              "Axis"
            ],
            "ifabsent": "False"
          },
          "title": "Grid"
        },
        "gridOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis grid lines. Should not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridOpacity",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Gridopacity"
        },
        "gridCap": {
          "anyOf": [
            {
              "$ref": "#/$defs/CapEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The stroke cap for axis grid lines. One of 'butt' (default), 'round' or 'square'.\nShould not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridCap",
            "domain_of": [
              "Axis"
            ]
          }
        },
        "gridColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Color of axis grid lines. Should not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridColor",
            "domain_of": [
              "Axis"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Gridcolor"
        },
        "gridWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Stroke width of axis grid lines. Should not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridWidth",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Gridwidth"
        },
        "labelColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Text color of axis tick labels.",
          "linkml_meta": {
            "alias": "labelColor",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Labelcolor"
        },
        "labelOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis tick labels.",
          "linkml_meta": {
            "alias": "labelOpacity",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelopacity"
        },
        "labelFont": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font name for axis tick labels.",
          "linkml_meta": {
            "alias": "labelFont",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfont"
        },
        "labelFontSize": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font size of axis tick labels.",
          "linkml_meta": {
            "alias": "labelFontSize",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfontsize"
        },
        "labelFontStyle": {
          "anyOf": [
            {
              "$ref": "#/$defs/FontStyleEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font style of axis tick labels",
          "linkml_meta": {
            "alias": "labelFontStyle",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "labelFontWeight": {
          "anyOf": [
            {
              "$ref": "#/$defs/FontWeightEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font weight of axis tick labels.",
          "linkml_meta": {
            "alias": "labelFontWeight",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "ticks": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": true,
          "description": "A boolean flag indicating if ticks should be included as part of the axis.",
          "linkml_meta": {
            "alias": "ticks",
            "domain_of": [
              "Axis"
            ],
            "ifabsent": "True"
          },
          "title": "Ticks"
        },
        "tickOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis ticks.",
          "linkml_meta": {
            "alias": "tickOpacity",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Tickopacity"
        },
        "tickColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Color of axis ticks.",
          "linkml_meta": {
            "alias": "tickColor",
            "domain_of": [
              "Axis"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Tickcolor"
        },
        "tickCap": {
          "anyOf": [
            {
              "$ref": "#/$defs/CapEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The stroke cap for axis tick marks. One of \"butt\" (default), \"round\" or \"square\".",
          "linkml_meta": {
            "alias": "tickCap",
            "domain_of": [
              "Axis"
            ]
          }
        },
        "tickWidth": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Width in pixels of axis ticks.",
          "linkml_meta": {
            "alias": "tickWidth",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Tickwidth"
        },
        "tickSize": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The length in pixels of axis ticks.",
          "linkml_meta": {
            "alias": "tickSize",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Ticksize"
        },
        "values": {
          "description": "Explicitly set the visible axis tick and label values. The array entries should be legal values in the \nbacking scale domain.",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "integer"
              }
            ]
          },
          "linkml_meta": {
            "alias": "values",
            "any_of": [
              {
                "range": "float"
              },
              {
                "range": "integer"
              }
            ],
            "domain_of": [
              "Axis",
              "ColorBarLegend"
            ]
          },
          "title": "Values",
          "type": "array"
        },
        "zindex": {
          "description": "The integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. \nThe default value is 0 and axes and grid lines are drawn behind any marks defined in the same specification \nlevel. Higher values (1) will cause axes and grid lines to be drawn on top of marks.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "number"
        }
      },
      "required": [
        "scale",
        "orient",
        "domain",
        "values",
        "zindex"
      ],
      "title": "Axis",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_marks__CategoricalLegend": {
      "additionalProperties": false,
      "description": "Type of legend for categorical data.",
      "properties": {
        "type": {
          "$ref": "#/$defs/LegendType",
          "description": "The type of legend, either 'gradient' (continuous data) or 'discrete' (categorical data).",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "direction": {
          "$ref": "#/$defs/LegendDirections",
          "description": "The direction of the legend, one of 'vertical' or 'horizontal'.",
          "linkml_meta": {
            "alias": "direction",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "orient": {
          "anyOf": [
            {
              "const": "none",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "none",
          "description": "The orientation of the legend, determining where the legend is placed relative to a chart's data rectangle. \nCurrently, only 'none' is allowed here as in Vega this allows to directly specify the positioning in \npixel coordinates. If there is demand, this can be changed.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Title",
              "Axis",
              "Legend"
            ],
            "equals_string": "none",
            "ifabsent": "string(none)"
          },
          "title": "Orient"
        },
        "padding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The padding between the border and content of the legend group in pixels.",
          "linkml_meta": {
            "alias": "padding",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Padding"
        },
        "fill": {
          "description": "The name of a scale that maps to a fill color. This represents the color used to visualize discrete classes\nor continuous data in the legend.",
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "title": "Fill",
          "type": "string"
        },
        "fillColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the background color of the legend.",
          "linkml_meta": {
            "alias": "fillColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Fillcolor"
        },
        "strokeColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the color of the legend border.",
          "linkml_meta": {
            "alias": "strokeColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Strokecolor"
        },
        "strokeWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The width of the legend border in pixels. This property deviates from its Vega equivalent, in that the \nvega equivalent expects a 'Scale'.",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "Legend"
            ]
          },
          "title": "Strokewidth"
        },
        "labelOffset": {
          "description": "Offset in pixels between legend labels their corresponding symbol or gradient.",
          "linkml_meta": {
            "alias": "labelOffset",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Labeloffset",
          "type": "number"
        },
        "labelAlign": {
          "$ref": "#/$defs/HorizontalAlignEnum",
          "description": "Horizontal text alignment for legend labels. In short this means where the label text is relative to the\nanchor point of the labels (this could be defined as the coordinates where the labels are specified to be).",
          "linkml_meta": {
            "alias": "labelAlign",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "labelColor": {
          "description": "Text color for legend labels represented by a RGB hex string.",
          "linkml_meta": {
            "alias": "labelColor",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Labelcolor",
          "type": "string"
        },
        "labelOpacity": {
          "description": "The opacity of legend labels.",
          "linkml_meta": {
            "alias": "labelOpacity",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Labelopacity",
          "type": "number"
        },
        "labelFont": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "Arial",
          "description": "Font name for legend labels.",
          "linkml_meta": {
            "alias": "labelFont",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "ifabsent": "string(Arial)"
          },
          "title": "Labelfont"
        },
        "labelFontSize": {
          "description": "Font size in pixels for legend labels.",
          "linkml_meta": {
            "alias": "labelFontSize",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfontsize",
          "type": "number"
        },
        "labelFontStyle": {
          "$ref": "#/$defs/FontStyleEnum",
          "description": "Font style of legend labels",
          "linkml_meta": {
            "alias": "labelFontStyle",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "labelFontWeight": {
          "$ref": "#/$defs/FontWeightEnum",
          "description": "Font weight of legend labels.",
          "linkml_meta": {
            "alias": "labelFontWeight",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "legendX": {
          "description": "The pixel x-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendX",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendx",
          "type": "number"
        },
        "legendY": {
          "description": "The pixel y-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendY",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendy",
          "type": "number"
        },
        "zindex": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 0,
          "description": "The integer z-index indicating the layering of the legend group relative to other axis, mark, and \nlegend groups.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ],
            "ifabsent": "0"
          },
          "title": "Zindex"
        },
        "columns": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row \nwith one column per entry. The default is 0 for horizontal symbol legends and 1 for vertical symbol legends.",
          "linkml_meta": {
            "alias": "columns",
            "domain_of": [
              "CategoricalLegend"
            ]
          },
          "title": "Columns"
        },
        "columnPadding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The horizontal padding in pixels between symbol legend entries.",
          "linkml_meta": {
            "alias": "columnPadding",
            "domain_of": [
              "CategoricalLegend"
            ]
          },
          "title": "Columnpadding"
        },
        "rowPadding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The vertical padding in pixels between symbol legend entries.",
          "linkml_meta": {
            "alias": "rowPadding",
            "domain_of": [
              "CategoricalLegend"
            ]
          },
          "title": "Rowpadding"
        }
      },
      "required": [
        "type",
        "direction",
        "fill",
        "labelOffset",
        "labelAlign",
        "labelColor",
        "labelOpacity",
        "labelFontSize",
        "labelFontStyle",
        "labelFontWeight",
        "legendX",
        "legendY"
      ],
      "title": "CategoricalLegend",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_marks__ColorBarLegend": {
      "additionalProperties": false,
      "description": "Type of legend for continuous data.",
      "properties": {
        "type": {
          "$ref": "#/$defs/LegendType",
          "description": "The type of legend, either 'gradient' (continuous data) or 'discrete' (categorical data).",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "direction": {
          "$ref": "#/$defs/LegendDirections",
          "description": "The direction of the legend, one of 'vertical' or 'horizontal'.",
          "linkml_meta": {
            "alias": "direction",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "orient": {
          "anyOf": [
            {
              "const": "none",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "none",
          "description": "The orientation of the legend, determining where the legend is placed relative to a chart's data rectangle. \nCurrently, only 'none' is allowed here as in Vega this allows to directly specify the positioning in \npixel coordinates. If there is demand, this can be changed.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Title",
              "Axis",
              "Legend"
            ],
            "equals_string": "none",
            "ifabsent": "string(none)"
          },
          "title": "Orient"
        },
        "padding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The padding between the border and content of the legend group in pixels.",
          "linkml_meta": {
            "alias": "padding",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Padding"
        },
        "fill": {
          "description": "The name of a scale that maps to a fill color. This represents the color used to visualize discrete classes\nor continuous data in the legend.",
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          },
          "title": "Fill",
          "type": "string"
        },
        "fillColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the background color of the legend.",
          "linkml_meta": {
            "alias": "fillColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Fillcolor"
        },
        "strokeColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the color of the legend border.",
          "linkml_meta": {
            "alias": "strokeColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Strokecolor"
        },
        "strokeWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The width of the legend border in pixels. This property deviates from its Vega equivalent, in that the \nvega equivalent expects a 'Scale'.",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "Legend"
            ]
          },
          "title": "Strokewidth"
        },
        "labelOffset": {
          "description": "Offset in pixels between legend labels their corresponding symbol or gradient.",
          "linkml_meta": {
            "alias": "labelOffset",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Labeloffset",
          "type": "number"
        },
        "labelAlign": {
          "$ref": "#/$defs/HorizontalAlignEnum",
          "description": "Horizontal text alignment for legend labels. In short this means where the label text is relative to the\nanchor point of the labels (this could be defined as the coordinates where the labels are specified to be).",
          "linkml_meta": {
            "alias": "labelAlign",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "labelColor": {
          "description": "Text color for legend labels represented by a RGB hex string.",
          "linkml_meta": {
            "alias": "labelColor",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Labelcolor",
          "type": "string"
        },
        "labelOpacity": {
          "description": "The opacity of legend labels.",
          "linkml_meta": {
            "alias": "labelOpacity",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Labelopacity",
          "type": "number"
        },
        "labelFont": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "Arial",
          "description": "Font name for legend labels.",
          "linkml_meta": {
            "alias": "labelFont",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "ifabsent": "string(Arial)"
          },
          "title": "Labelfont"
        },
        "labelFontSize": {
          "description": "Font size in pixels for legend labels.",
          "linkml_meta": {
            "alias": "labelFontSize",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfontsize",
          "type": "number"
        },
        "labelFontStyle": {
          "$ref": "#/$defs/FontStyleEnum",
          "description": "Font style of legend labels",
          "linkml_meta": {
            "alias": "labelFontStyle",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "labelFontWeight": {
          "$ref": "#/$defs/FontWeightEnum",
          "description": "Font weight of legend labels.",
          "linkml_meta": {
            "alias": "labelFontWeight",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "legendX": {
          "description": "The pixel x-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendX",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendx",
          "type": "number"
        },
        "legendY": {
          "description": "The pixel y-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendY",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendy",
          "type": "number"
        },
        "zindex": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 0,
          "description": "The integer z-index indicating the layering of the legend group relative to other axis, mark, and \nlegend groups.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ],
            "ifabsent": "0"
          },
          "title": "Zindex"
        },
        "gradientLength": {
          "description": "The length in pixels of the primary axis of a color gradient. This value corresponds to the height of a \nvertical gradient or the width of a horizontal gradient.",
          "linkml_meta": {
            "alias": "gradientLength",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "title": "Gradientlength",
          "type": "number"
        },
        "gradientThickness": {
          "description": "The thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or \nthe height of a horizontal gradient.",
          "linkml_meta": {
            "alias": "gradientThickness",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "minimum": 0,
          "title": "Gradientthickness",
          "type": "number"
        },
        "gradientOpacity": {
          "description": "Opacity of the color gradient.",
          "linkml_meta": {
            "alias": "gradientOpacity",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Gradientopacity",
          "type": "number"
        },
        "gradientStrokeColor": {
          "description": "Stroke color of the color gradient border.",
          "linkml_meta": {
            "alias": "gradientStrokeColor",
            "domain_of": [
              "ColorBarLegend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Gradientstrokecolor",
          "type": "string"
        },
        "gradientStrokeWidth": {
          "description": "Stroke width of the color gradient border.",
          "linkml_meta": {
            "alias": "gradientStrokeWidth",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "title": "Gradientstrokewidth",
          "type": "number"
        },
        "values": {
          "description": "Explicitly set the visible legend values. The array entries should be legal values in the backing scale \ndomain.",
          "items": {
            "type": "number"
          },
          "linkml_meta": {
            "alias": "values",
            "domain_of": [
              "Axis",
              "ColorBarLegend"
            ]
          },
          "title": "Values",
          "type": "array"
        }
      },
      "required": [
        "type",
        "direction",
        "fill",
        "labelOffset",
        "labelAlign",
        "labelColor",
        "labelOpacity",
        "labelFontSize",
        "labelFontStyle",
        "labelFontWeight",
        "legendX",
        "legendY",
        "gradientLength",
        "gradientThickness",
        "gradientOpacity",
        "gradientStrokeColor",
        "gradientStrokeWidth",
        "values"
      ],
      "title": "ColorBarLegend",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_marks__TextEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position and appearance of a text mark.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene and are the only properties\nsupported for a text mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/vega_scverse__spec_models__linkml_marks__TextEncodeEnter",
          "description": "Enter properties that are evaluated when data for a text mark is processed for the first time and the \ngroup mark is newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "TextEncode",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_marks__TextEncodeEnter": {
      "additionalProperties": false,
      "description": "Enter properties that are evaluated when data for a text mark is processed for the first time and the\ngroup mark is newly added to a scene.",
      "properties": {
        "x": {
          "$ref": "#/$defs/PositionItem",
          "linkml_meta": {
            "alias": "x",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "y": {
          "$ref": "#/$defs/PositionItem",
          "linkml_meta": {
            "alias": "y",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "text": {
          "$ref": "#/$defs/TextItem",
          "linkml_meta": {
            "alias": "text",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "align": {
          "$ref": "#/$defs/HorizontalAlignObject",
          "description": "The horizontal text alignment relative to the text anchor point.",
          "linkml_meta": {
            "alias": "align",
            "domain_of": [
              "TextEncodeEnter"
            ]
          }
        },
        "angle": {
          "anyOf": [
            {
              "maximum": 359,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The rotation angle of the text in degrees.",
          "linkml_meta": {
            "alias": "angle",
            "domain_of": [
              "TextEncodeEnter"
            ]
          },
          "title": "Angle"
        },
        "baseline": {
          "$ref": "#/$defs/BaseLineObject",
          "description": "The baseline attribute specifies the vertical alignment (baseline) of the text relative to its y-coordinate.",
          "linkml_meta": {
            "alias": "baseline",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "font": {
          "$ref": "#/$defs/FontItem",
          "linkml_meta": {
            "alias": "font",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontSize": {
          "$ref": "#/$defs/FontSizeItem",
          "linkml_meta": {
            "alias": "fontSize",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontWeight": {
          "$ref": "#/$defs/FontWeightItem",
          "linkml_meta": {
            "alias": "fontWeight",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontStyle": {
          "$ref": "#/$defs/FontStyleItem",
          "linkml_meta": {
            "alias": "fontStyle",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fill": {
          "$ref": "#/$defs/RGBHexItem",
          "description": "The color of the text",
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate",
              "Legend"
            ]
          }
        },
        "fillOpacity": {
          "anyOf": [
            {
              "$ref": "#/$defs/OpacityObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of the text.",
          "linkml_meta": {
            "alias": "fillOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter"
            ]
          }
        }
      },
      "required": [
        "x",
        "y",
        "text",
        "align",
        "baseline",
        "font",
        "fontSize",
        "fontWeight",
        "fontStyle",
        "fill"
      ],
      "title": "TextEncodeEnter",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_marks__TextMark": {
      "additionalProperties": false,
      "description": "Text marks can be used to annotate data and provide labels and titles for axes and legends.",
      "properties": {
        "type": {
          "anyOf": [
            {
              "const": "text",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "text",
          "description": "The type of the mark. In this case, it is always 'text'.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "text",
            "ifabsent": "string(text)"
          },
          "title": "Type"
        },
        "encode": {
          "anyOf": [
            {
              "$ref": "#/$defs/vega_scverse__spec_models__linkml_marks__TextEncode"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "zindex": {
          "description": "An integer z-index indicating the layering order of sibling mark items. The default value is 0. Higher values \n(1) will cause marks to be drawn on top of those with lower z-index values.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "integer"
        }
      },
      "required": [
        "zindex"
      ],
      "title": "TextMark",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_specification__Axis": {
      "additionalProperties": false,
      "description": "An axis visualizes a spatial scale mapping for cartesian coordinates using ticks, grid lines and labels.",
      "properties": {
        "scale": {
          "description": "Name of the 'AxisScale' to visualize as axis object.",
          "linkml_meta": {
            "alias": "scale",
            "domain_of": [
              "Axis",
              "ColorItem",
              "AxisItem",
              "ConditionalFillUpdate"
            ]
          },
          "title": "Scale",
          "type": "string"
        },
        "orient": {
          "$ref": "#/$defs/OrientEnum",
          "description": "The orientation of the axis, either 'left', 'right', 'top' or 'bottom'.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Axis",
              "Legend",
              "Title"
            ]
          }
        },
        "domain": {
          "description": "A boolean flag indicating if the domain (the axis baseline, the line that the ticks connect to) should be \nincluded as part of the axis.",
          "linkml_meta": {
            "alias": "domain",
            "domain_of": [
              "BaseAxisScale",
              "LinearColorScale",
              "BaseCategoricalColorScale",
              "Axis"
            ]
          },
          "title": "Domain",
          "type": "boolean"
        },
        "domainOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis domain line. Should not be present if domain is 'false'.",
          "linkml_meta": {
            "alias": "domainOpacity",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Domainopacity"
        },
        "domainColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Color of axis domain line. Should not be present if domain is 'false'.",
          "linkml_meta": {
            "alias": "domainColor",
            "domain_of": [
              "Axis"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Domaincolor"
        },
        "domainWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Stroke width of axis domain line. Should not be present if domain is 'false'.",
          "linkml_meta": {
            "alias": "domainWidth",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Domainwidth"
        },
        "grid": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": false,
          "description": "A boolean flag indicating if grid lines should be included as part of the axis.",
          "linkml_meta": {
            "alias": "grid",
            "domain_of": [
              "Axis"
            ],
            "ifabsent": "False"
          },
          "title": "Grid"
        },
        "gridOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis grid lines. Should not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridOpacity",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Gridopacity"
        },
        "gridCap": {
          "anyOf": [
            {
              "$ref": "#/$defs/CapEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The stroke cap for axis grid lines. One of 'butt' (default), 'round' or 'square'.\nShould not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridCap",
            "domain_of": [
              "Axis"
            ]
          }
        },
        "gridColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Color of axis grid lines. Should not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridColor",
            "domain_of": [
              "Axis"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Gridcolor"
        },
        "gridWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Stroke width of axis grid lines. Should not be present if grid is 'false'.",
          "linkml_meta": {
            "alias": "gridWidth",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Gridwidth"
        },
        "labelColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Text color of axis tick labels.",
          "linkml_meta": {
            "alias": "labelColor",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Labelcolor"
        },
        "labelOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis tick labels.",
          "linkml_meta": {
            "alias": "labelOpacity",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelopacity"
        },
        "labelFont": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font name for axis tick labels.",
          "linkml_meta": {
            "alias": "labelFont",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfont"
        },
        "labelFontSize": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font size of axis tick labels.",
          "linkml_meta": {
            "alias": "labelFontSize",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfontsize"
        },
        "labelFontStyle": {
          "anyOf": [
            {
              "$ref": "#/$defs/FontStyleEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font style of axis tick labels",
          "linkml_meta": {
            "alias": "labelFontStyle",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "labelFontWeight": {
          "anyOf": [
            {
              "$ref": "#/$defs/FontWeightEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Font weight of axis tick labels.",
          "linkml_meta": {
            "alias": "labelFontWeight",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "ticks": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": true,
          "description": "A boolean flag indicating if ticks should be included as part of the axis.",
          "linkml_meta": {
            "alias": "ticks",
            "domain_of": [
              "Axis"
            ],
            "ifabsent": "True"
          },
          "title": "Ticks"
        },
        "tickOpacity": {
          "anyOf": [
            {
              "maximum": 1,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of axis ticks.",
          "linkml_meta": {
            "alias": "tickOpacity",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Tickopacity"
        },
        "tickColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Color of axis ticks.",
          "linkml_meta": {
            "alias": "tickColor",
            "domain_of": [
              "Axis"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Tickcolor"
        },
        "tickCap": {
          "anyOf": [
            {
              "$ref": "#/$defs/CapEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The stroke cap for axis tick marks. One of \"butt\" (default), \"round\" or \"square\".",
          "linkml_meta": {
            "alias": "tickCap",
            "domain_of": [
              "Axis"
            ]
          }
        },
        "tickWidth": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Width in pixels of axis ticks.",
          "linkml_meta": {
            "alias": "tickWidth",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Tickwidth"
        },
        "tickSize": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The length in pixels of axis ticks.",
          "linkml_meta": {
            "alias": "tickSize",
            "domain_of": [
              "Axis"
            ]
          },
          "title": "Ticksize"
        },
        "values": {
          "description": "Explicitly set the visible axis tick and label values. The array entries should be legal values in the \nbacking scale domain.",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "integer"
              }
            ]
          },
          "linkml_meta": {
            "alias": "values",
            "any_of": [
              {
                "range": "float"
              },
              {
                "range": "integer"
              }
            ],
            "domain_of": [
              "BaseLookupTransform",
              "Axis",
              "ColorBarLegend"
            ]
          },
          "title": "Values",
          "type": "array"
        },
        "zindex": {
          "description": "The integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. \nThe default value is 0 and axes and grid lines are drawn behind any marks defined in the same specification \nlevel. Higher values (1) will cause axes and grid lines to be drawn on top of marks.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "number"
        }
      },
      "required": [
        "scale",
        "orient",
        "domain",
        "values",
        "zindex"
      ],
      "title": "Axis",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_specification__CategoricalLegend": {
      "additionalProperties": false,
      "description": "Type of legend for categorical data.",
      "properties": {
        "type": {
          "$ref": "#/$defs/LegendType",
          "description": "The type of legend, either 'gradient' (continuous data) or 'discrete' (categorical data).",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat",
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "direction": {
          "$ref": "#/$defs/LegendDirections",
          "description": "The direction of the legend, one of 'vertical' or 'horizontal'.",
          "linkml_meta": {
            "alias": "direction",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "orient": {
          "anyOf": [
            {
              "const": "none",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "none",
          "description": "The orientation of the legend, determining where the legend is placed relative to a chart's data rectangle. \nCurrently, only 'none' is allowed here as in Vega this allows to directly specify the positioning in \npixel coordinates. If there is demand, this can be changed.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Axis",
              "Legend",
              "Title"
            ],
            "equals_string": "none",
            "ifabsent": "string(none)"
          },
          "title": "Orient"
        },
        "padding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The padding between the border and content of the legend group in pixels.",
          "linkml_meta": {
            "alias": "padding",
            "domain_of": [
              "Legend",
              "BaseViewConfiguration"
            ]
          },
          "title": "Padding"
        },
        "fill": {
          "description": "The name of a scale that maps to a fill color. This represents the color used to visualize discrete classes\nor continuous data in the legend.",
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "Legend",
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate"
            ]
          },
          "title": "Fill",
          "type": "string"
        },
        "fillColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the background color of the legend.",
          "linkml_meta": {
            "alias": "fillColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Fillcolor"
        },
        "strokeColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the color of the legend border.",
          "linkml_meta": {
            "alias": "strokeColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Strokecolor"
        },
        "strokeWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The width of the legend border in pixels. This property deviates from its Vega equivalent, in that the \nvega equivalent expects a 'Scale'.",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "Legend",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          },
          "title": "Strokewidth"
        },
        "labelOffset": {
          "description": "Offset in pixels between legend labels their corresponding symbol or gradient.",
          "linkml_meta": {
            "alias": "labelOffset",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Labeloffset",
          "type": "number"
        },
        "labelAlign": {
          "$ref": "#/$defs/HorizontalAlignEnum",
          "description": "Horizontal text alignment for legend labels. In short this means where the label text is relative to the\nanchor point of the labels (this could be defined as the coordinates where the labels are specified to be).",
          "linkml_meta": {
            "alias": "labelAlign",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "labelColor": {
          "description": "Text color for legend labels represented by a RGB hex string.",
          "linkml_meta": {
            "alias": "labelColor",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Labelcolor",
          "type": "string"
        },
        "labelOpacity": {
          "description": "The opacity of legend labels.",
          "linkml_meta": {
            "alias": "labelOpacity",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Labelopacity",
          "type": "number"
        },
        "labelFont": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "Arial",
          "description": "Font name for legend labels.",
          "linkml_meta": {
            "alias": "labelFont",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "ifabsent": "string(Arial)"
          },
          "title": "Labelfont"
        },
        "labelFontSize": {
          "description": "Font size in pixels for legend labels.",
          "linkml_meta": {
            "alias": "labelFontSize",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfontsize",
          "type": "number"
        },
        "labelFontStyle": {
          "$ref": "#/$defs/FontStyleEnum",
          "description": "Font style of legend labels",
          "linkml_meta": {
            "alias": "labelFontStyle",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "labelFontWeight": {
          "$ref": "#/$defs/FontWeightEnum",
          "description": "Font weight of legend labels.",
          "linkml_meta": {
            "alias": "labelFontWeight",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "legendX": {
          "description": "The pixel x-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendX",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendx",
          "type": "number"
        },
        "legendY": {
          "description": "The pixel y-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendY",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendy",
          "type": "number"
        },
        "zindex": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 0,
          "description": "The integer z-index indicating the layering of the legend group relative to other axis, mark, and \nlegend groups.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ],
            "ifabsent": "0"
          },
          "title": "Zindex"
        },
        "columns": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row \nwith one column per entry. The default is 0 for horizontal symbol legends and 1 for vertical symbol legends.",
          "linkml_meta": {
            "alias": "columns",
            "domain_of": [
              "CategoricalLegend"
            ]
          },
          "title": "Columns"
        },
        "columnPadding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The horizontal padding in pixels between symbol legend entries.",
          "linkml_meta": {
            "alias": "columnPadding",
            "domain_of": [
              "CategoricalLegend"
            ]
          },
          "title": "Columnpadding"
        },
        "rowPadding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The vertical padding in pixels between symbol legend entries.",
          "linkml_meta": {
            "alias": "rowPadding",
            "domain_of": [
              "CategoricalLegend"
            ]
          },
          "title": "Rowpadding"
        }
      },
      "required": [
        "type",
        "direction",
        "fill",
        "labelOffset",
        "labelAlign",
        "labelColor",
        "labelOpacity",
        "labelFontSize",
        "labelFontStyle",
        "labelFontWeight",
        "legendX",
        "legendY"
      ],
      "title": "CategoricalLegend",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_specification__ColorBarLegend": {
      "additionalProperties": false,
      "description": "Type of legend for continuous data.",
      "properties": {
        "type": {
          "$ref": "#/$defs/LegendType",
          "description": "The type of legend, either 'gradient' (continuous data) or 'discrete' (categorical data).",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat",
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "direction": {
          "$ref": "#/$defs/LegendDirections",
          "description": "The direction of the legend, one of 'vertical' or 'horizontal'.",
          "linkml_meta": {
            "alias": "direction",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "orient": {
          "anyOf": [
            {
              "const": "none",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "none",
          "description": "The orientation of the legend, determining where the legend is placed relative to a chart's data rectangle. \nCurrently, only 'none' is allowed here as in Vega this allows to directly specify the positioning in \npixel coordinates. If there is demand, this can be changed.",
          "linkml_meta": {
            "alias": "orient",
            "domain_of": [
              "Axis",
              "Legend",
              "Title"
            ],
            "equals_string": "none",
            "ifabsent": "string(none)"
          },
          "title": "Orient"
        },
        "padding": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The padding between the border and content of the legend group in pixels.",
          "linkml_meta": {
            "alias": "padding",
            "domain_of": [
              "Legend",
              "BaseViewConfiguration"
            ]
          },
          "title": "Padding"
        },
        "fill": {
          "description": "The name of a scale that maps to a fill color. This represents the color used to visualize discrete classes\nor continuous data in the legend.",
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "Legend",
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate"
            ]
          },
          "title": "Fill",
          "type": "string"
        },
        "fillColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the background color of the legend.",
          "linkml_meta": {
            "alias": "fillColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Fillcolor"
        },
        "strokeColor": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hex string representing a RGBA color, which is the color of the legend border.",
          "linkml_meta": {
            "alias": "strokeColor",
            "domain_of": [
              "Legend"
            ],
            "slot_uri": "rgbaHexSlot"
          },
          "title": "Strokecolor"
        },
        "strokeWidth": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The width of the legend border in pixels. This property deviates from its Vega equivalent, in that the \nvega equivalent expects a 'Scale'.",
          "linkml_meta": {
            "alias": "strokeWidth",
            "domain_of": [
              "Legend",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter"
            ]
          },
          "title": "Strokewidth"
        },
        "labelOffset": {
          "description": "Offset in pixels between legend labels their corresponding symbol or gradient.",
          "linkml_meta": {
            "alias": "labelOffset",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Labeloffset",
          "type": "number"
        },
        "labelAlign": {
          "$ref": "#/$defs/HorizontalAlignEnum",
          "description": "Horizontal text alignment for legend labels. In short this means where the label text is relative to the\nanchor point of the labels (this could be defined as the coordinates where the labels are specified to be).",
          "linkml_meta": {
            "alias": "labelAlign",
            "domain_of": [
              "Legend"
            ]
          }
        },
        "labelColor": {
          "description": "Text color for legend labels represented by a RGB hex string.",
          "linkml_meta": {
            "alias": "labelColor",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Labelcolor",
          "type": "string"
        },
        "labelOpacity": {
          "description": "The opacity of legend labels.",
          "linkml_meta": {
            "alias": "labelOpacity",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Labelopacity",
          "type": "number"
        },
        "labelFont": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "Arial",
          "description": "Font name for legend labels.",
          "linkml_meta": {
            "alias": "labelFont",
            "domain_of": [
              "Axis",
              "Legend"
            ],
            "ifabsent": "string(Arial)"
          },
          "title": "Labelfont"
        },
        "labelFontSize": {
          "description": "Font size in pixels for legend labels.",
          "linkml_meta": {
            "alias": "labelFontSize",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          },
          "title": "Labelfontsize",
          "type": "number"
        },
        "labelFontStyle": {
          "$ref": "#/$defs/FontStyleEnum",
          "description": "Font style of legend labels",
          "linkml_meta": {
            "alias": "labelFontStyle",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "labelFontWeight": {
          "$ref": "#/$defs/FontWeightEnum",
          "description": "Font weight of legend labels.",
          "linkml_meta": {
            "alias": "labelFontWeight",
            "domain_of": [
              "Axis",
              "Legend"
            ]
          }
        },
        "legendX": {
          "description": "The pixel x-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendX",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendx",
          "type": "number"
        },
        "legendY": {
          "description": "The pixel y-coordinate of the legend group.",
          "linkml_meta": {
            "alias": "legendY",
            "domain_of": [
              "Legend"
            ]
          },
          "title": "Legendy",
          "type": "number"
        },
        "zindex": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 0,
          "description": "The integer z-index indicating the layering of the legend group relative to other axis, mark, and \nlegend groups.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ],
            "ifabsent": "0"
          },
          "title": "Zindex"
        },
        "gradientLength": {
          "description": "The length in pixels of the primary axis of a color gradient. This value corresponds to the height of a \nvertical gradient or the width of a horizontal gradient.",
          "linkml_meta": {
            "alias": "gradientLength",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "title": "Gradientlength",
          "type": "number"
        },
        "gradientThickness": {
          "description": "The thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or \nthe height of a horizontal gradient.",
          "linkml_meta": {
            "alias": "gradientThickness",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "minimum": 0,
          "title": "Gradientthickness",
          "type": "number"
        },
        "gradientOpacity": {
          "description": "Opacity of the color gradient.",
          "linkml_meta": {
            "alias": "gradientOpacity",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "maximum": 1,
          "minimum": 0,
          "title": "Gradientopacity",
          "type": "number"
        },
        "gradientStrokeColor": {
          "description": "Stroke color of the color gradient border.",
          "linkml_meta": {
            "alias": "gradientStrokeColor",
            "domain_of": [
              "ColorBarLegend"
            ],
            "slot_uri": "rgbHexSlot"
          },
          "title": "Gradientstrokecolor",
          "type": "string"
        },
        "gradientStrokeWidth": {
          "description": "Stroke width of the color gradient border.",
          "linkml_meta": {
            "alias": "gradientStrokeWidth",
            "domain_of": [
              "ColorBarLegend"
            ]
          },
          "title": "Gradientstrokewidth",
          "type": "number"
        },
        "values": {
          "description": "Explicitly set the visible legend values. The array entries should be legal values in the backing scale \ndomain.",
          "items": {
            "type": "number"
          },
          "linkml_meta": {
            "alias": "values",
            "domain_of": [
              "BaseLookupTransform",
              "Axis",
              "ColorBarLegend"
            ]
          },
          "title": "Values",
          "type": "array"
        }
      },
      "required": [
        "type",
        "direction",
        "fill",
        "labelOffset",
        "labelAlign",
        "labelColor",
        "labelOpacity",
        "labelFontSize",
        "labelFontStyle",
        "labelFontWeight",
        "legendX",
        "legendY",
        "gradientLength",
        "gradientThickness",
        "gradientOpacity",
        "gradientStrokeColor",
        "gradientStrokeWidth",
        "values"
      ],
      "title": "ColorBarLegend",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_specification__TextEncode": {
      "additionalProperties": false,
      "description": "A set of visual encoding properties that determine the position and appearance of a text mark.\nIn Vega, there are three primary property sets: enter, update, exit. The enter properties are evaluated when data\nis processed for the first time and a mark instance is newly added to a scene and are the only properties\nsupported for a text mark.",
      "properties": {
        "enter": {
          "$ref": "#/$defs/vega_scverse__spec_models__linkml_specification__TextEncodeEnter",
          "description": "Enter properties that are evaluated when data for a text mark is processed for the first time and the \ngroup mark is newly added to a scene.",
          "linkml_meta": {
            "alias": "enter",
            "domain_of": [
              "ImageEncode",
              "LabelEncode",
              "SymbolEncode",
              "PathEncode",
              "TextEncode",
              "GroupEncode"
            ]
          }
        }
      },
      "required": [
        "enter"
      ],
      "title": "TextEncode",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_specification__TextEncodeEnter": {
      "additionalProperties": false,
      "description": "Enter properties that are evaluated when data for a text mark is processed for the first time and the\ngroup mark is newly added to a scene.",
      "properties": {
        "x": {
          "$ref": "#/$defs/PositionItem",
          "linkml_meta": {
            "alias": "x",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "y": {
          "$ref": "#/$defs/PositionItem",
          "linkml_meta": {
            "alias": "y",
            "domain_of": [
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "GroupEncodeEnter"
            ]
          }
        },
        "text": {
          "$ref": "#/$defs/TextItem",
          "linkml_meta": {
            "alias": "text",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "align": {
          "$ref": "#/$defs/HorizontalAlignObject",
          "description": "The horizontal text alignment relative to the text anchor point.",
          "linkml_meta": {
            "alias": "align",
            "domain_of": [
              "TextEncodeEnter"
            ]
          }
        },
        "angle": {
          "anyOf": [
            {
              "maximum": 359,
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The rotation angle of the text in degrees.",
          "linkml_meta": {
            "alias": "angle",
            "domain_of": [
              "TextEncodeEnter"
            ]
          },
          "title": "Angle"
        },
        "baseline": {
          "$ref": "#/$defs/BaseLineObject",
          "description": "The baseline attribute specifies the vertical alignment (baseline) of the text relative to its y-coordinate.",
          "linkml_meta": {
            "alias": "baseline",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "font": {
          "$ref": "#/$defs/FontItem",
          "linkml_meta": {
            "alias": "font",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontSize": {
          "$ref": "#/$defs/FontSizeItem",
          "linkml_meta": {
            "alias": "fontSize",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontWeight": {
          "$ref": "#/$defs/FontWeightItem",
          "linkml_meta": {
            "alias": "fontWeight",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fontStyle": {
          "$ref": "#/$defs/FontStyleItem",
          "linkml_meta": {
            "alias": "fontStyle",
            "domain_of": [
              "Title",
              "TextEncodeEnter"
            ]
          }
        },
        "fill": {
          "$ref": "#/$defs/RGBHexItem",
          "description": "The color of the text",
          "linkml_meta": {
            "alias": "fill",
            "domain_of": [
              "Legend",
              "ImageEncodeEnter",
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter",
              "MarkEncodeUpdate"
            ]
          }
        },
        "fillOpacity": {
          "anyOf": [
            {
              "$ref": "#/$defs/OpacityObject"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Opacity of the text.",
          "linkml_meta": {
            "alias": "fillOpacity",
            "domain_of": [
              "LabelEncodeEnter",
              "PointsEncodeEnter",
              "PathEncodeEnter",
              "TextEncodeEnter"
            ]
          }
        }
      },
      "required": [
        "x",
        "y",
        "text",
        "align",
        "baseline",
        "font",
        "fontSize",
        "fontWeight",
        "fontStyle",
        "fill"
      ],
      "title": "TextEncodeEnter",
      "type": "object"
    },
    "vega_scverse__spec_models__linkml_specification__TextMark": {
      "additionalProperties": false,
      "description": "Text marks can be used to annotate data and provide labels and titles for axes and legends.",
      "properties": {
        "type": {
          "anyOf": [
            {
              "const": "text",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "text",
          "description": "The type of the mark. In this case, it is always 'text'.",
          "linkml_meta": {
            "alias": "type",
            "domain_of": [
              "Transform",
              "BaseFormat",
              "Scale",
              "Legend",
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ],
            "equals_string": "text",
            "ifabsent": "string(text)"
          },
          "title": "Type"
        },
        "encode": {
          "anyOf": [
            {
              "$ref": "#/$defs/vega_scverse__spec_models__linkml_specification__TextEncode"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "linkml_meta": {
            "alias": "encode",
            "domain_of": [
              "Mark",
              "TextMark",
              "BaseGroupMark"
            ]
          }
        },
        "zindex": {
          "description": "An integer z-index indicating the layering order of sibling mark items. The default value is 0. Higher values \n(1) will cause marks to be drawn on top of those with lower z-index values.",
          "linkml_meta": {
            "alias": "zindex",
            "domain_of": [
              "Axis",
              "Legend",
              "Mark",
              "TextMark"
            ]
          },
          "title": "Zindex",
          "type": "integer"
        }
      },
      "required": [
        "zindex"
      ],
      "title": "TextMark",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "https://github.com/melonora/vega-scverse/blob/main/src/vega_scverse/schema/linkml_specification.yaml",
      "description": "The schema version",
      "linkml_meta": {
        "alias": "$schema",
        "domain_of": [
          "BaseViewConfiguration"
        ],
        "ifabsent": "string(https://github.com/melonora/vega-scverse/blob/main/src/vega_scverse/schema/linkml_specification.yaml)"
      },
      "title": "$Schema"
    },
    "height": {
      "description": "The height of the plotting area. The plotting area is defined as the rectangular region within a visualization \nwhere graphical marks (such as points, lines, or bars) are rendered, bounded by the axes and padding, \nexcluding titles, legends, and margins.",
      "linkml_meta": {
        "alias": "height",
        "domain_of": [
          "GroupEncodeEnter",
          "BaseViewConfiguration"
        ]
      },
      "title": "Height",
      "type": "integer"
    },
    "width": {
      "description": "The width of the plotting area. The plotting area is defined as the rectangular region within a visualization \nwhere graphical marks (such as points, lines, or bars) are rendered, bounded by the axes and padding, \nexcluding titles, legends, and margins.",
      "linkml_meta": {
        "alias": "width",
        "domain_of": [
          "GroupEncodeEnter",
          "BaseViewConfiguration"
        ]
      },
      "title": "Width",
      "type": "integer"
    },
    "padding": {
      "anyOf": [
        {
          "$ref": "#/$defs/Padding"
        },
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "padding defines the amount of space (in pixels) to reserve between the edge of the chart container and the inner \nview area where data marks are rendered. It acts as an internal margin that ensures visual elements like axes, \ntitles, and legends don't touch or overflow the chart's outer boundaries.\nWhen combined with \"autosize\": {\"type\": \"fit\", \"contains\": \"padding\"}, this padding is included within the chart's \nspecified width and height, and the inner view is resized accordingly to preserve layout integrity. If padding\nis defined with this class. This class should at least have one attribute defined.",
      "linkml_meta": {
        "alias": "padding",
        "any_of": [
          {
            "range": "float"
          },
          {
            "range": "Padding"
          }
        ],
        "domain_of": [
          "Legend",
          "BaseViewConfiguration"
        ]
      },
      "title": "Padding"
    },
    "title": {
      "anyOf": [
        {
          "$ref": "#/$defs/Title"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "The title directive adds a descriptive title to a chart.",
      "linkml_meta": {
        "alias": "title",
        "domain_of": [
          "BaseViewConfiguration"
        ]
      }
    },
    "data": {
      "description": "Scverse data set definitions and transforms define the data to load and how to process it.",
      "items": {
        "anyOf": [
          {
            "$ref": "#/$defs/SpatialDataElementObject"
          },
          {
            "$ref": "#/$defs/TableObject"
          },
          {
            "$ref": "#/$defs/SpatialDataObject"
          }
        ]
      },
      "linkml_meta": {
        "alias": "data",
        "any_of": [
          {
            "range": "SpatialDataObject"
          },
          {
            "range": "BaseTableObject"
          },
          {
            "range": "BaseSpatialDataElementObject"
          }
        ],
        "domain_of": [
          "ContinuousColorDomain",
          "MarkDataSource",
          "BaseViewConfiguration"
        ]
      },
      "title": "Data",
      "type": "array"
    },
    "scales": {
      "anyOf": [
        {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/AxisScale"
              },
              {
                "$ref": "#/$defs/CategoricalColorScale"
              },
              {
                "$ref": "#/$defs/LinearColorScale"
              }
            ]
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Scales map data values (numbers, dates, categories, etc.) to visual values (pixels, colors, sizes).\n        Scales are a fundamental building block of data visualization, as they determine the nature of visual\n        encodings.",
      "linkml_meta": {
        "alias": "scales",
        "any_of": [
          {
            "range": "BaseAxisScale"
          },
          {
            "range": "BaseCategoricalColorScale"
          },
          {
            "range": "LinearColorScale"
          }
        ],
        "domain_of": [
          "BaseScales",
          "BaseGroupMark"
        ]
      },
      "title": "Scales"
    },
    "axes": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/vega_scverse__spec_models__linkml_specification__Axis"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Axes visualize spatial scale mappings using ticks, grid lines and labels.",
      "linkml_meta": {
        "alias": "axes",
        "domain_of": [
          "BaseGroupMark",
          "BaseViewConfiguration"
        ]
      },
      "title": "Axes"
    },
    "legend": {
      "anyOf": [
        {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/vega_scverse__spec_models__linkml_specification__CategoricalLegend"
              },
              {
                "$ref": "#/$defs/vega_scverse__spec_models__linkml_specification__ColorBarLegend"
              }
            ]
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Legends visualize scale mappings for visual values such as color, shape and size.",
      "linkml_meta": {
        "alias": "legend",
        "any_of": [
          {
            "range": "CategoricalLegend"
          },
          {
            "range": "ColorBarLegend"
          }
        ],
        "domain_of": [
          "BaseGroupMark",
          "BaseViewConfiguration"
        ]
      },
      "title": "Legend"
    },
    "marks": {
      "description": "Graphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting\n    symbols. Marks are the basic visual building block of a visualization, providing basic shapes whose\n    properties can be set according to backing data. Mark property definitions may be simple constants or data\n    fields, or scales can be used to map data values to visual values.",
      "items": {
        "anyOf": [
          {
            "$ref": "#/$defs/GroupMark"
          },
          {
            "$ref": "#/$defs/PointsMark"
          },
          {
            "$ref": "#/$defs/RasterImageMark"
          },
          {
            "$ref": "#/$defs/RasterLabelMark"
          },
          {
            "$ref": "#/$defs/ShapesMark"
          },
          {
            "$ref": "#/$defs/vega_scverse__spec_models__linkml_specification__TextMark"
          }
        ]
      },
      "linkml_meta": {
        "alias": "marks",
        "any_of": [
          {
            "range": "BaseRasterImageMark"
          },
          {
            "range": "BaseRasterLabelMark"
          },
          {
            "range": "BasePointsMark"
          },
          {
            "range": "BaseShapesMark"
          },
          {
            "range": "TextMark"
          },
          {
            "range": "BaseGroupMark"
          }
        ],
        "domain_of": [
          "BaseGroupMark",
          "BaseViewConfiguration"
        ]
      },
      "title": "Marks",
      "type": "array"
    }
  },
  "required": [
    "height",
    "width",
    "data",
    "marks"
  ],
  "title": "ViewConfiguration",
  "type": "object"
}